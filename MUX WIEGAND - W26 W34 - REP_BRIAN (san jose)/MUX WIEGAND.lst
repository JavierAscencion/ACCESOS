CCS PCM C Compiler, Version 5.080, 13314               17-jun.-21 11:57

               Filename:   D:\Google Drive\MUX WIEGAND - W26 W34 - REP_BRIAN\MUX WIEGAND.lst

               ROM used:   2823 words (34%)
                           Largest free fragment is 2048
               RAM used:   250 (68%) at main() level
                           255 (69%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   29B
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.3
0028:  GOTO   02B
0029:  BTFSC  0B.0
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.0
002E:  GOTO   031
002F:  BTFSC  0C.0
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   07C
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   058
.................... //2021/06/17 Se invierte etiqueta de lectora para corregir problema del sistema con nips 
.................... //2021/06/16 Se emula codigo de mux de Brian 
.................... //2020/09/30 Actualizado Ahora se pueden conectar tarjetas wiegand26 o 34 sin reprogramar 
.................... //           Ahora tambien envian la tecla pulsada 
.................... //           Compatible con lectoras Zkteco y Dahua 
.................... //           Caso Mifare: Las lectoras Dahua envian el paquete en un oreden distinto NO MEZCLAR con otra marca 
.................... //           Caso ID: se pueden mezclar las marcas 
.................... //2017/11/15 
.................... #include <16F727.h> 
.................... //////////// Standard Header file for the PIC16F727 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F727 
*
0174:  DATA CD,2A
0175:  DATA D8,20
0176:  DATA AD,24
0177:  DATA 44,2C
0178:  DATA BA,12
0179:  DATA 30,1C
017A:  DATA 4C,2C
017B:  DATA 0D,00
017C:  DATA CD,2A
017D:  DATA 58,21
017E:  DATA 2D,27
017F:  DATA 49,28
0180:  DATA BA,12
0181:  DATA F5,12
0182:  DATA F5,12
0183:  DATA F5,12
0184:  DATA F5,06
0185:  DATA 80,2B
0186:  DATA CD,2A
0187:  DATA 58,21
0188:  DATA AD,24
0189:  DATA 44,2C
018A:  DATA BA,12
018B:  DATA 30,1C
018C:  DATA 4C,2C
018D:  DATA 0D,00
018E:  DATA CD,2A
018F:  DATA D8,20
0190:  DATA 2D,27
0191:  DATA 49,28
0192:  DATA BA,12
0193:  DATA F5,12
0194:  DATA F5,12
0195:  DATA F5,12
0196:  DATA F5,06
0197:  DATA 00,01
0198:  DATA CD,2A
0199:  DATA D8,21
019A:  DATA AD,24
019B:  DATA 44,2C
019C:  DATA BA,12
019D:  DATA 30,1C
019E:  DATA 4C,2C
019F:  DATA 0D,00
01A0:  DATA CD,2A
01A1:  DATA D8,21
01A2:  DATA 2D,27
01A3:  DATA 49,28
01A4:  DATA BA,12
01A5:  DATA F5,12
01A6:  DATA F5,12
01A7:  DATA F5,12
01A8:  DATA F5,06
01A9:  DATA 00,01
01AA:  DATA CD,2A
01AB:  DATA 58,22
01AC:  DATA AD,24
01AD:  DATA 44,2C
01AE:  DATA BA,12
01AF:  DATA 30,1C
01B0:  DATA 4C,2C
01B1:  DATA 0D,00
01B2:  DATA CD,2A
01B3:  DATA 58,22
01B4:  DATA 2D,27
01B5:  DATA 49,28
01B6:  DATA BA,12
01B7:  DATA F5,12
01B8:  DATA F5,12
01B9:  DATA F5,12
01BA:  DATA F5,06
01BB:  DATA 00,00
01BC:  MOVF   78,W
01BD:  BTFSC  03.2
01BE:  GOTO   1C4
01BF:  MOVF   77,W
01C0:  MOVWF  00
01C1:  INCF   04,F
01C2:  DECFSZ 78,F
01C3:  GOTO   1BF
01C4:  RETURN
01C5:  MOVF   0B,W
01C6:  BSF    03.6
01C7:  MOVWF  59
01C8:  BCF    03.6
01C9:  BCF    0B.7
01CA:  BSF    03.5
01CB:  BSF    03.6
01CC:  BSF    0C.7
01CD:  BSF    0C.0
01CE:  NOP
01CF:  NOP
01D0:  BCF    03.5
01D1:  BTFSS  59.7
01D2:  GOTO   1D6
01D3:  BCF    03.6
01D4:  BSF    0B.7
01D5:  BSF    03.6
01D6:  BTFSC  03.0
01D7:  GOTO   1FE
01D8:  MOVF   0C,W
01D9:  ANDLW  7F
01DA:  MOVWF  59
01DB:  MOVF   0D,W
01DC:  MOVWF  5A
01DD:  MOVF   0F,W
01DE:  MOVWF  5B
01DF:  MOVF   59,W
01E0:  BCF    03.6
01E1:  BTFSS  0C.4
01E2:  GOTO   1E1
01E3:  MOVWF  19
01E4:  BSF    03.6
01E5:  MOVF   5A,W
01E6:  MOVWF  0D
01E7:  MOVF   5B,W
01E8:  MOVWF  0F
01E9:  BCF    03.6
01EA:  MOVF   0B,W
01EB:  BSF    03.6
01EC:  MOVWF  5C
01ED:  BCF    03.6
01EE:  BCF    0B.7
01EF:  BSF    03.5
01F0:  BSF    03.6
01F1:  BSF    0C.7
01F2:  BSF    0C.0
01F3:  NOP
01F4:  NOP
01F5:  BCF    03.5
01F6:  BTFSS  5C.7
01F7:  GOTO   1FB
01F8:  BCF    03.6
01F9:  BSF    0B.7
01FA:  BSF    03.6
01FB:  DECFSZ 58,F
01FC:  GOTO   1FE
01FD:  GOTO   219
01FE:  RLF    0C,W
01FF:  RLF    0E,W
0200:  ANDLW  7F
0201:  MOVWF  59
0202:  MOVF   0D,W
0203:  MOVWF  5A
0204:  MOVF   0F,W
0205:  MOVWF  5B
0206:  MOVF   59,W
0207:  BCF    03.6
0208:  BTFSS  0C.4
0209:  GOTO   208
020A:  MOVWF  19
020B:  BSF    03.6
020C:  MOVF   5A,W
020D:  MOVWF  0D
020E:  MOVF   5B,W
020F:  MOVWF  0F
0210:  INCF   0D,F
0211:  BTFSC  03.2
0212:  INCF   0F,F
0213:  BCF    03.0
0214:  DECFSZ 58,F
0215:  GOTO   217
0216:  GOTO   219
0217:  BCF    03.6
0218:  GOTO   1C5
0219:  BCF    03.6
021A:  RETURN
021B:  BSF    03.6
021C:  BTFSC  59.7
021D:  GOTO   231
021E:  MOVLW  0F
021F:  MOVWF  77
0220:  SWAPF  58,W
0221:  ANDWF  77,F
0222:  MOVLW  0A
0223:  SUBWF  77,W
0224:  BTFSC  03.0
0225:  GOTO   229
0226:  MOVLW  30
0227:  ADDWF  77,F
0228:  GOTO   22B
0229:  MOVF   59,W
022A:  ADDWF  77,F
022B:  MOVF   77,W
022C:  BCF    03.6
022D:  BTFSS  0C.4
022E:  GOTO   22D
022F:  MOVWF  19
0230:  BSF    03.6
0231:  MOVLW  0F
0232:  ANDWF  58,F
0233:  MOVLW  0A
0234:  SUBWF  58,W
0235:  BTFSC  03.0
0236:  GOTO   239
0237:  MOVLW  30
0238:  GOTO   23B
0239:  BCF    59.7
023A:  MOVF   59,W
023B:  ADDWF  58,F
023C:  MOVF   58,W
023D:  BCF    03.6
023E:  BTFSS  0C.4
023F:  GOTO   23E
0240:  MOVWF  19
0241:  RETURN
0242:  BSF    03.6
0243:  MOVF   5B,W
0244:  CLRF   78
0245:  SUBWF  5A,W
0246:  BTFSC  03.0
0247:  GOTO   24B
0248:  MOVF   5A,W
0249:  MOVWF  77
024A:  GOTO   257
024B:  CLRF   77
024C:  MOVLW  08
024D:  MOVWF  5C
024E:  RLF    5A,F
024F:  RLF    77,F
0250:  MOVF   5B,W
0251:  SUBWF  77,W
0252:  BTFSC  03.0
0253:  MOVWF  77
0254:  RLF    78,F
0255:  DECFSZ 5C,F
0256:  GOTO   24E
0257:  BCF    03.6
0258:  RETURN
0259:  MOVF   78,W
025A:  BSF    03.6
025B:  MOVF   58,W
025C:  MOVWF  5A
025D:  MOVLW  64
025E:  MOVWF  5B
025F:  BCF    03.6
0260:  CALL   242
0261:  MOVF   77,W
0262:  BSF    03.6
0263:  MOVWF  58
0264:  MOVF   78,W
0265:  MOVLW  30
0266:  BTFSS  03.2
0267:  GOTO   26F
0268:  BTFSS  59.1
0269:  GOTO   279
026A:  BTFSC  59.3
026B:  GOTO   279
026C:  BTFSC  59.4
026D:  MOVLW  20
026E:  GOTO   272
026F:  BCF    59.3
0270:  BCF    59.4
0271:  BSF    59.0
0272:  ADDWF  78,F
0273:  MOVF   78,W
0274:  BCF    03.6
0275:  BTFSS  0C.4
0276:  GOTO   275
0277:  MOVWF  19
0278:  BSF    03.6
0279:  MOVF   58,W
027A:  MOVWF  5A
027B:  MOVLW  0A
027C:  MOVWF  5B
027D:  BCF    03.6
027E:  CALL   242
027F:  MOVF   77,W
0280:  BSF    03.6
0281:  MOVWF  58
0282:  MOVF   78,W
0283:  MOVLW  30
0284:  BTFSS  03.2
0285:  GOTO   28C
0286:  BTFSC  59.3
0287:  GOTO   293
0288:  BTFSS  59.0
0289:  GOTO   293
028A:  BTFSC  59.4
028B:  MOVLW  20
028C:  ADDWF  78,F
028D:  MOVF   78,W
028E:  BCF    03.6
028F:  BTFSS  0C.4
0290:  GOTO   28F
0291:  MOVWF  19
0292:  BSF    03.6
0293:  MOVLW  30
0294:  ADDWF  58,F
0295:  MOVF   58,W
0296:  BCF    03.6
0297:  BTFSS  0C.4
0298:  GOTO   297
0299:  MOVWF  19
029A:  RETURN
....................  
.................... #list 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
02B8:  BCF    03.5
02B9:  BCF    03.6
02BA:  CLRF   2B
02BB:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #use delay (clock=20000000) 
.................... #fuses HS,PROTECT,NOWDT//WDT_2304MS 
.................... #use rs232(uart1, baud=115200,TIMEOUT=10) 
....................  
.................... ////SALIDAS 
.................... #define indicadorA PIN_D2// 
.................... #define indicadorB PIN_D3// 
.................... #define indicadorC PIN_D0// 
.................... #define indicadorD PIN_D1// 
.................... #define salida01 PIN_C0// 
.................... #define salida02 PIN_C1// 
.................... #define salida03 PIN_C2// 
.................... #define salida04 PIN_C5// 
....................  
.................... //AD1-B0,AD0-B1,BD1-B2,BD0-B3,CD0-B4 
.................... int16 i; 
.................... ////////VARIABLES WIEGAND///////// 
.................... const int wieg_size= 34;//tamao maximo  
.................... //// 
.................... int cta_reini; 
.................... int apagarA,time_apagarA,apagarB,time_apagarB,apagarC,time_apagarC,apagarD,time_apagarD; 
....................  
.................... int deteccion_nulo_a,pre_cuenta_a; 
.................... int nipA[4],nipB[4],nipC[4],nipD[4],time_nip[4],f_nip[4]; 
.................... int ia,ib,ic,id,mi,relay[4],t_relay[4]; 
.................... int wieg_a; 
.................... int sub_indice_a=0; 
.................... int wieg_full_a=0; 
.................... int wiegand_cuenta_a; 
.................... unsigned int32 deci_a; 
.................... char data_a[wieg_size]; 
.................... //// 
.................... int deteccion_nulo_b,pre_cuenta_b; 
.................... int wieg_b; 
.................... int sub_indice_b=0; 
.................... int wieg_full_b=0; 
.................... int wiegand_cuenta_b; 
.................... unsigned int32 deci_b; 
.................... char data_b[wieg_size]; 
.................... //// 
.................... int deteccion_nulo_c,pre_cuenta_c; 
.................... int wieg_c; 
.................... int sub_indice_c=0; 
.................... int wieg_full_c=0; 
.................... int wiegand_cuenta_c; 
.................... unsigned int32 deci_c; 
.................... char data_c[wieg_size]; 
.................... //// 
.................... int deteccion_nulo_d,pre_cuenta_d; 
.................... int wieg_d; 
.................... int sub_indice_d=0; 
.................... int wieg_full_d=0; 
.................... int wiegand_cuenta_d; 
.................... unsigned int32 deci_d; 
.................... char data_d[wieg_size]; 
.................... /////////////////////////////// 
.................... void wiegand_read_card(); 
....................  
.................... #int_TIMER1 //se utiliza timer 1 porque el 0 esta asignado al wdt 
.................... void TIMER1_isr(void){ 
.................... //Nuestro cdigo de interrupcin. 
.................... wiegand_cuenta_a++; 
*
0058:  INCF   67,F
.................... wiegand_cuenta_b++; 
0059:  INCF   71,F
.................... wiegand_cuenta_c++; 
005A:  BSF    03.5
005B:  INCF   64,F
.................... wiegand_cuenta_d++; 
005C:  INCF   6E,F
.................... time_apagarA++; 
005D:  BCF    03.5
005E:  INCF   36,F
.................... time_apagarB++; 
005F:  INCF   38,F
.................... time_apagarC++; 
0060:  INCF   3A,F
.................... time_apagarD++; 
0061:  INCF   3C,F
.................... for(mi=0;mi<4;mi++) { 
0062:  CLRF   5B
0063:  MOVF   5B,W
0064:  SUBLW  03
0065:  BTFSS  03.0
0066:  GOTO   073
....................    time_nip[mi]++; 
0067:  MOVLW  4F
0068:  ADDWF  5B,W
0069:  MOVWF  04
006A:  BCF    03.7
006B:  INCF   00,F
....................    t_relay[mi]++;} 
006C:  MOVLW  60
006D:  ADDWF  5B,W
006E:  MOVWF  04
006F:  BCF    03.7
0070:  INCF   00,F
0071:  INCF   5B,F
0072:  GOTO   063
.................... set_timer1(0x3CB0);//80ms 
0073:  CLRF   0E
0074:  MOVLW  3C
0075:  MOVWF  0F
0076:  MOVLW  B0
0077:  MOVWF  0E
.................... } 
....................  
0078:  BCF    0C.0
0079:  BCF    0A.3
007A:  BCF    0A.4
007B:  GOTO   031
.................... #INT_RB 
.................... void INT_RB_isr(void){ 
.................... ///////////LECTORA A 
....................  if (!input(PIN_B0) ){//data1 
007C:  BSF    03.5
007D:  BSF    06.0
007E:  BCF    03.5
007F:  BTFSC  06.0
0080:  GOTO   09A
....................    output_high(indicadorA); 
0081:  BSF    03.5
0082:  BCF    08.2
0083:  BCF    03.5
0084:  BSF    08.2
....................    while (!input(PIN_B0) ) {} 
0085:  BSF    03.5
0086:  BSF    06.0
0087:  BCF    03.5
0088:  BTFSS  06.0
0089:  GOTO   085
....................    wiegand_cuenta_a=0; 
008A:  CLRF   67
....................    wieg_a=1; 
008B:  MOVLW  01
008C:  MOVWF  64
....................    data_a[sub_indice_a]=1; 
008D:  MOVLW  A0
008E:  ADDWF  65,W
008F:  MOVWF  04
0090:  BCF    03.7
0091:  MOVLW  01
0092:  MOVWF  00
....................    sub_indice_a++; 
0093:  INCF   65,F
....................    if(sub_indice_a==wieg_size)  wieg_full_a=1; 
0094:  MOVF   65,W
0095:  SUBLW  22
0096:  BTFSS  03.2
0097:  GOTO   09A
0098:  MOVLW  01
0099:  MOVWF  66
....................  } 
....................  if (!input(PIN_B1) ){//data0 
009A:  BSF    03.5
009B:  BSF    06.1
009C:  BCF    03.5
009D:  BTFSC  06.1
009E:  GOTO   0B7
....................    output_high(indicadorA); 
009F:  BSF    03.5
00A0:  BCF    08.2
00A1:  BCF    03.5
00A2:  BSF    08.2
....................    while (!input(PIN_B1) ) {} 
00A3:  BSF    03.5
00A4:  BSF    06.1
00A5:  BCF    03.5
00A6:  BTFSS  06.1
00A7:  GOTO   0A3
....................    wiegand_cuenta_a=0; 
00A8:  CLRF   67
....................    wieg_a=1; 
00A9:  MOVLW  01
00AA:  MOVWF  64
....................    data_a[sub_indice_a]=0; 
00AB:  MOVLW  A0
00AC:  ADDWF  65,W
00AD:  MOVWF  04
00AE:  BCF    03.7
00AF:  CLRF   00
....................    sub_indice_a++; 
00B0:  INCF   65,F
....................    if(sub_indice_a==wieg_size)  wieg_full_a=1; 
00B1:  MOVF   65,W
00B2:  SUBLW  22
00B3:  BTFSS  03.2
00B4:  GOTO   0B7
00B5:  MOVLW  01
00B6:  MOVWF  66
....................  } 
.................... ///////////LECTORA B 
....................  if (!input(PIN_B2) ){//data1 
00B7:  BSF    03.5
00B8:  BSF    06.2
00B9:  BCF    03.5
00BA:  BTFSC  06.2
00BB:  GOTO   0D5
....................    output_high(indicadorB); 
00BC:  BSF    03.5
00BD:  BCF    08.3
00BE:  BCF    03.5
00BF:  BSF    08.3
....................    while (!input(PIN_B2) ) {} 
00C0:  BSF    03.5
00C1:  BSF    06.2
00C2:  BCF    03.5
00C3:  BTFSS  06.2
00C4:  GOTO   0C0
....................    wiegand_cuenta_b=0; 
00C5:  CLRF   71
....................    wieg_b=1; 
00C6:  MOVLW  01
00C7:  MOVWF  6E
....................    data_b[sub_indice_b]=1; 
00C8:  MOVLW  C2
00C9:  ADDWF  6F,W
00CA:  MOVWF  04
00CB:  BCF    03.7
00CC:  MOVLW  01
00CD:  MOVWF  00
....................    sub_indice_b++; 
00CE:  INCF   6F,F
....................    if(sub_indice_b==wieg_size)  wieg_full_b=1; 
00CF:  MOVF   6F,W
00D0:  SUBLW  22
00D1:  BTFSS  03.2
00D2:  GOTO   0D5
00D3:  MOVLW  01
00D4:  MOVWF  70
....................  }// 
....................  if (!input(PIN_B3) ){//data0 
00D5:  BSF    03.5
00D6:  BSF    06.3
00D7:  BCF    03.5
00D8:  BTFSC  06.3
00D9:  GOTO   0F2
....................    output_high(indicadorB); 
00DA:  BSF    03.5
00DB:  BCF    08.3
00DC:  BCF    03.5
00DD:  BSF    08.3
....................    while (!input(PIN_B3) ) {} 
00DE:  BSF    03.5
00DF:  BSF    06.3
00E0:  BCF    03.5
00E1:  BTFSS  06.3
00E2:  GOTO   0DE
....................    wiegand_cuenta_b=0; 
00E3:  CLRF   71
....................    wieg_b=1; 
00E4:  MOVLW  01
00E5:  MOVWF  6E
....................    data_b[sub_indice_b]=0; 
00E6:  MOVLW  C2
00E7:  ADDWF  6F,W
00E8:  MOVWF  04
00E9:  BCF    03.7
00EA:  CLRF   00
....................    sub_indice_b++; 
00EB:  INCF   6F,F
....................    if(sub_indice_b==wieg_size)  wieg_full_b=1; 
00EC:  MOVF   6F,W
00ED:  SUBLW  22
00EE:  BTFSS  03.2
00EF:  GOTO   0F2
00F0:  MOVLW  01
00F1:  MOVWF  70
....................  } 
.................... ///////////LECTORA C 
....................  if (!input(PIN_B4) ){//data1 
00F2:  BSF    03.5
00F3:  BSF    06.4
00F4:  BCF    03.5
00F5:  BTFSC  06.4
00F6:  GOTO   112
....................    output_high(indicadorC); 
00F7:  BSF    03.5
00F8:  BCF    08.0
00F9:  BCF    03.5
00FA:  BSF    08.0
....................    while (!input(PIN_B4) ) {} 
00FB:  BSF    03.5
00FC:  BSF    06.4
00FD:  BCF    03.5
00FE:  BTFSS  06.4
00FF:  GOTO   0FB
....................    wiegand_cuenta_c=0; 
0100:  BSF    03.5
0101:  CLRF   64
....................    wieg_c=1; 
0102:  MOVLW  01
0103:  MOVWF  7C
....................    data_c[sub_indice_c]=1; 
0104:  MOVLW  10
0105:  ADDWF  7D,W
0106:  MOVWF  04
0107:  BSF    03.7
0108:  MOVLW  01
0109:  MOVWF  00
....................    sub_indice_c++; 
010A:  INCF   7D,F
....................    if(sub_indice_c==wieg_size)  wieg_full_c=1; 
010B:  MOVF   7D,W
010C:  SUBLW  22
010D:  BTFSS  03.2
010E:  GOTO   111
010F:  MOVLW  01
0110:  MOVWF  7E
0111:  BCF    03.5
....................  }// 
....................  if (!input(PIN_B5) ){//data0 
0112:  BSF    03.5
0113:  BSF    06.5
0114:  BCF    03.5
0115:  BTFSC  06.5
0116:  GOTO   131
....................    output_high(indicadorC); 
0117:  BSF    03.5
0118:  BCF    08.0
0119:  BCF    03.5
011A:  BSF    08.0
....................    while (!input(PIN_B5) ) {} 
011B:  BSF    03.5
011C:  BSF    06.5
011D:  BCF    03.5
011E:  BTFSS  06.5
011F:  GOTO   11B
....................    wiegand_cuenta_c=0; 
0120:  BSF    03.5
0121:  CLRF   64
....................    wieg_c=1; 
0122:  MOVLW  01
0123:  MOVWF  7C
....................    data_c[sub_indice_c]=0; 
0124:  MOVLW  10
0125:  ADDWF  7D,W
0126:  MOVWF  04
0127:  BSF    03.7
0128:  CLRF   00
....................    sub_indice_c++; 
0129:  INCF   7D,F
....................    if(sub_indice_c==wieg_size)  wieg_full_c=1; 
012A:  MOVF   7D,W
012B:  SUBLW  22
012C:  BTFSS  03.2
012D:  GOTO   130
012E:  MOVLW  01
012F:  MOVWF  7E
0130:  BCF    03.5
....................  } 
.................... ///////////LECTORA D 
....................  if (!input(PIN_B6) ){//data1 
0131:  BSF    03.5
0132:  BSF    06.6
0133:  BCF    03.5
0134:  BTFSC  06.6
0135:  GOTO   151
....................    output_high(indicadorD); 
0136:  BSF    03.5
0137:  BCF    08.1
0138:  BCF    03.5
0139:  BSF    08.1
....................    while (!input(PIN_B6) ) {} 
013A:  BSF    03.5
013B:  BSF    06.6
013C:  BCF    03.5
013D:  BTFSS  06.6
013E:  GOTO   13A
....................    wiegand_cuenta_d=0; 
013F:  BSF    03.5
0140:  CLRF   6E
....................    wieg_d=1; 
0141:  MOVLW  01
0142:  MOVWF  6B
....................    data_d[sub_indice_d]=1; 
0143:  MOVLW  36
0144:  ADDWF  6C,W
0145:  MOVWF  04
0146:  BSF    03.7
0147:  MOVLW  01
0148:  MOVWF  00
....................    sub_indice_d++; 
0149:  INCF   6C,F
....................    if(sub_indice_d==wieg_size)  wieg_full_d=1; 
014A:  MOVF   6C,W
014B:  SUBLW  22
014C:  BTFSS  03.2
014D:  GOTO   150
014E:  MOVLW  01
014F:  MOVWF  6D
0150:  BCF    03.5
....................  }// 
....................  if (!input(PIN_B7) ){//data0 
0151:  BSF    03.5
0152:  BSF    06.7
0153:  BCF    03.5
0154:  BTFSC  06.7
0155:  GOTO   170
....................    output_high(indicadorD); 
0156:  BSF    03.5
0157:  BCF    08.1
0158:  BCF    03.5
0159:  BSF    08.1
....................    while (!input(PIN_B7) ) {} 
015A:  BSF    03.5
015B:  BSF    06.7
015C:  BCF    03.5
015D:  BTFSS  06.7
015E:  GOTO   15A
....................    wiegand_cuenta_d=0; 
015F:  BSF    03.5
0160:  CLRF   6E
....................    wieg_d=1; 
0161:  MOVLW  01
0162:  MOVWF  6B
....................    data_d[sub_indice_d]=0; 
0163:  MOVLW  36
0164:  ADDWF  6C,W
0165:  MOVWF  04
0166:  BSF    03.7
0167:  CLRF   00
....................    sub_indice_d++; 
0168:  INCF   6C,F
....................    if(sub_indice_d==wieg_size)  wieg_full_d=1; 
0169:  MOVF   6C,W
016A:  SUBLW  22
016B:  BTFSS  03.2
016C:  GOTO   16F
016D:  MOVLW  01
016E:  MOVWF  6D
016F:  BCF    03.5
....................  } 
....................  
0170:  BCF    0B.0
0171:  BCF    0A.3
0172:  BCF    0A.4
0173:  GOTO   031
.................... } 
....................  
.................... void main() { 
*
029B:  MOVF   03,W
029C:  ANDLW  1F
029D:  MOVWF  03
029E:  CLRF   31
029F:  MOVLW  0A
02A0:  BSF    03.5
02A1:  MOVWF  19
02A2:  MOVLW  A6
02A3:  MOVWF  18
02A4:  MOVLW  90
02A5:  BCF    03.5
02A6:  MOVWF  18
02A7:  CLRF   65
02A8:  CLRF   66
02A9:  CLRF   6F
02AA:  CLRF   70
02AB:  CLRF   7D
02AC:  CLRF   7E
02AD:  BSF    03.5
02AE:  CLRF   6C
02AF:  CLRF   6D
02B0:  MOVLW  FF
02B1:  MOVWF  6F
02B2:  BSF    03.6
02B3:  CLRF   05
02B4:  CLRF   06
02B5:  CLRF   08
02B6:  CLRF   09
02B7:  BCF    03.7
.................... //setup_oscillator(OSC_8MHZ|OSC_INTRC);//<<<<<<<<<<<<<<< 
.................... setup_adc_ports(NO_ANALOGS); 
*
02BC:  BSF    03.5
02BD:  BCF    1F.0
02BE:  BCF    1F.1
02BF:  MOVLW  00
02C0:  BSF    03.6
02C1:  MOVWF  05
02C2:  MOVWF  09
02C3:  MOVWF  06
02C4:  MOVWF  08
.................... setup_adc(ADC_OFF); 
02C5:  BCF    03.5
02C6:  BCF    03.6
02C7:  BCF    1F.0
.................... setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);//Setup timer: Reloj interno, preescaler= 8 
02C8:  MOVLW  35
02C9:  MOVWF  10
02CA:  BSF    03.5
02CB:  CLRF   0F
.................... enable_interrupts(INT_TIMER1);//Habilito interrupcin particular del TIMER1 
02CC:  BSF    0C.0
.................... set_timer1(0x3CB0);//Carga del TMR1 
02CD:  BCF    03.5
02CE:  CLRF   0E
02CF:  MOVLW  3C
02D0:  MOVWF  0F
02D1:  MOVLW  B0
02D2:  MOVWF  0E
....................  
.................... ext_int_edge(INT_RB,H_TO_L);       //Asigno flancos de subida 
02D3:  BSF    03.5
02D4:  BCF    01.6
.................... enable_interrupts(INT_RB);//interrupcion de puerto 
02D5:  BCF    03.5
02D6:  BSF    0B.3
02D7:  MOVLW  FF
02D8:  BSF    03.5
02D9:  IORWF  16,F
.................... enable_interrupts(INT_RB0); 
02DA:  BCF    03.5
02DB:  BSF    0B.3
02DC:  BSF    03.5
02DD:  BSF    16.0
.................... enable_interrupts(INT_RB1); 
02DE:  BCF    03.5
02DF:  BSF    0B.3
02E0:  BSF    03.5
02E1:  BSF    16.1
.................... enable_interrupts(INT_RB2); 
02E2:  BCF    03.5
02E3:  BSF    0B.3
02E4:  BSF    03.5
02E5:  BSF    16.2
.................... enable_interrupts(INT_RB3); 
02E6:  BCF    03.5
02E7:  BSF    0B.3
02E8:  BSF    03.5
02E9:  BSF    16.3
.................... enable_interrupts(INT_RB4); 
02EA:  BCF    03.5
02EB:  BSF    0B.3
02EC:  BSF    03.5
02ED:  BSF    16.4
.................... enable_interrupts(INT_RB5); 
02EE:  BCF    03.5
02EF:  BSF    0B.3
02F0:  BSF    03.5
02F1:  BSF    16.5
.................... enable_interrupts(INT_RB6); 
02F2:  BCF    03.5
02F3:  BSF    0B.3
02F4:  BSF    03.5
02F5:  BSF    16.6
.................... enable_interrupts(INT_RB7); 
02F6:  BCF    03.5
02F7:  BSF    0B.3
02F8:  BSF    03.5
02F9:  BSF    16.7
.................... cta_reini++; 
02FA:  BCF    03.5
02FB:  INCF   34,F
.................... //printf("\r\nINICIADO:%u",cta_reini); 
.................... ///////////////// 
.................... wieg_full_a=0; 
02FC:  CLRF   66
.................... deci_a=0; 
02FD:  CLRF   6B
02FE:  CLRF   6A
02FF:  CLRF   69
0300:  CLRF   68
.................... deteccion_nulo_a=0; 
0301:  CLRF   3D
.................... pre_cuenta_a=0; 
0302:  CLRF   3E
.................... wieg_a=sub_indice_a=i=0; 
0303:  CLRF   33
0304:  CLRF   32
0305:  MOVF   32,W
0306:  MOVWF  65
0307:  MOVWF  64
.................... wiegand_cuenta_a=2; 
0308:  MOVLW  02
0309:  MOVWF  67
.................... for(i=0;i<wieg_size;i++) data_a[i]=0; 
030A:  CLRF   33
030B:  CLRF   32
030C:  MOVF   33,F
030D:  BTFSS  03.2
030E:  GOTO   31E
030F:  MOVF   32,W
0310:  SUBLW  21
0311:  BTFSS  03.0
0312:  GOTO   31E
0313:  MOVLW  A0
0314:  ADDWF  32,W
0315:  MOVWF  04
0316:  BCF    03.7
0317:  BTFSC  33.0
0318:  BSF    03.7
0319:  CLRF   00
031A:  INCF   32,F
031B:  BTFSC  03.2
031C:  INCF   33,F
031D:  GOTO   30C
.................... // 
.................... wieg_full_b=0; 
031E:  CLRF   70
.................... deci_b=0; 
031F:  CLRF   75
0320:  CLRF   74
0321:  CLRF   73
0322:  CLRF   72
.................... deteccion_nulo_b=0; 
0323:  CLRF   6C
.................... pre_cuenta_b=0; 
0324:  CLRF   6D
.................... wieg_b=sub_indice_b=i=0; 
0325:  CLRF   33
0326:  CLRF   32
0327:  MOVF   32,W
0328:  MOVWF  6F
0329:  MOVWF  6E
.................... wiegand_cuenta_b=2; 
032A:  MOVLW  02
032B:  MOVWF  71
.................... for(i=0;i<wieg_size;i++) data_b[i]=0; 
032C:  CLRF   33
032D:  CLRF   32
032E:  MOVF   33,F
032F:  BTFSS  03.2
0330:  GOTO   340
0331:  MOVF   32,W
0332:  SUBLW  21
0333:  BTFSS  03.0
0334:  GOTO   340
0335:  MOVLW  C2
0336:  ADDWF  32,W
0337:  MOVWF  04
0338:  BCF    03.7
0339:  BTFSC  33.0
033A:  BSF    03.7
033B:  CLRF   00
033C:  INCF   32,F
033D:  BTFSC  03.2
033E:  INCF   33,F
033F:  GOTO   32E
.................... wieg_full_c=0; 
0340:  CLRF   7E
.................... deci_c=0; 
0341:  BSF    03.5
0342:  CLRF   68
0343:  CLRF   67
0344:  CLRF   66
0345:  CLRF   65
.................... deteccion_nulo_c=0; 
0346:  CLRF   76
.................... pre_cuenta_c=0; 
0347:  CLRF   7B
.................... wieg_c=sub_indice_c=i=0; 
0348:  BCF    03.5
0349:  CLRF   33
034A:  CLRF   32
034B:  MOVF   32,W
034C:  MOVWF  7D
034D:  MOVWF  7C
.................... wiegand_cuenta_c=2; 
034E:  MOVLW  02
034F:  BSF    03.5
0350:  MOVWF  64
.................... for(i=0;i<wieg_size;i++) data_c[i]=0; 
0351:  BCF    03.5
0352:  CLRF   33
0353:  CLRF   32
0354:  MOVF   33,F
0355:  BTFSS  03.2
0356:  GOTO   364
0357:  MOVF   32,W
0358:  SUBLW  21
0359:  BTFSS  03.0
035A:  GOTO   364
035B:  MOVLW  10
035C:  ADDWF  32,W
035D:  MOVWF  04
035E:  BSF    03.7
035F:  CLRF   00
0360:  INCF   32,F
0361:  BTFSC  03.2
0362:  INCF   33,F
0363:  GOTO   354
.................... // 
.................... wieg_full_d=0; 
0364:  BSF    03.5
0365:  CLRF   6D
.................... deci_d=0; 
0366:  BCF    03.5
0367:  BSF    03.6
0368:  CLRF   35
0369:  CLRF   34
036A:  CLRF   33
036B:  CLRF   32
.................... deteccion_nulo_d=0; 
036C:  BSF    03.5
036D:  BCF    03.6
036E:  CLRF   69
.................... pre_cuenta_d=0; 
036F:  CLRF   6A
.................... wieg_d=sub_indice_d=i=0; 
0370:  BCF    03.5
0371:  CLRF   33
0372:  CLRF   32
0373:  MOVF   32,W
0374:  BSF    03.5
0375:  MOVWF  6C
0376:  MOVWF  6B
.................... wiegand_cuenta_d=2; 
0377:  MOVLW  02
0378:  MOVWF  6E
.................... for(i=0;i<wieg_size;i++) data_d[i]=0; 
0379:  BCF    03.5
037A:  CLRF   33
037B:  CLRF   32
037C:  MOVF   33,F
037D:  BTFSS  03.2
037E:  GOTO   38C
037F:  MOVF   32,W
0380:  SUBLW  21
0381:  BTFSS  03.0
0382:  GOTO   38C
0383:  MOVLW  36
0384:  ADDWF  32,W
0385:  MOVWF  04
0386:  BSF    03.7
0387:  CLRF   00
0388:  INCF   32,F
0389:  BTFSC  03.2
038A:  INCF   33,F
038B:  GOTO   37C
....................  
.................... enable_interrupts(GLOBAL);//Habilito interrupciones globales 
038C:  MOVLW  C0
038D:  IORWF  0B,F
.................... apagarA=apagarB=apagarC=apagarD=0; 
038E:  CLRF   3B
038F:  MOVF   3B,W
0390:  MOVWF  39
0391:  MOVWF  37
0392:  MOVWF  35
....................  
.................... memset(nipA, 0, sizeof(nipA)); 
0393:  MOVLW  3F
0394:  MOVWF  04
0395:  BCF    03.7
0396:  CLRF   77
0397:  MOVLW  04
0398:  MOVWF  78
0399:  CALL   1BC
.................... memset(nipB, 0, sizeof(nipB)); 
039A:  MOVLW  43
039B:  MOVWF  04
039C:  BCF    03.7
039D:  CLRF   77
039E:  MOVLW  04
039F:  MOVWF  78
03A0:  CALL   1BC
.................... memset(nipC, 0, sizeof(nipC)); 
03A1:  MOVLW  47
03A2:  MOVWF  04
03A3:  BCF    03.7
03A4:  CLRF   77
03A5:  MOVLW  04
03A6:  MOVWF  78
03A7:  CALL   1BC
.................... memset(nipD, 0, sizeof(nipD)); 
03A8:  MOVLW  4B
03A9:  MOVWF  04
03AA:  BCF    03.7
03AB:  CLRF   77
03AC:  MOVLW  04
03AD:  MOVWF  78
03AE:  CALL   1BC
.................... memset(time_nip, 0, sizeof(time_nip)); 
03AF:  MOVLW  4F
03B0:  MOVWF  04
03B1:  BCF    03.7
03B2:  CLRF   77
03B3:  MOVLW  04
03B4:  MOVWF  78
03B5:  CALL   1BC
.................... memset(f_nip, 0, sizeof(f_nip)); 
03B6:  MOVLW  53
03B7:  MOVWF  04
03B8:  BCF    03.7
03B9:  CLRF   77
03BA:  MOVLW  04
03BB:  MOVWF  78
03BC:  CALL   1BC
.................... ia=ib=ic=id=0; 
03BD:  CLRF   5A
03BE:  MOVF   5A,W
03BF:  MOVWF  59
03C0:  MOVWF  58
03C1:  MOVWF  57
.................... memset(relay, 0, sizeof(relay)); 
03C2:  MOVLW  5C
03C3:  MOVWF  04
03C4:  BCF    03.7
03C5:  CLRF   77
03C6:  MOVLW  04
03C7:  MOVWF  78
03C8:  CALL   1BC
.................... memset(t_relay, 0, sizeof(t_relay)); 
03C9:  MOVLW  60
03CA:  MOVWF  04
03CB:  BCF    03.7
03CC:  CLRF   77
03CD:  MOVLW  04
03CE:  MOVWF  78
03CF:  CALL   1BC
.................... output_low(salida01); 
03D0:  BSF    03.5
03D1:  BCF    6F.0
03D2:  MOVF   6F,W
03D3:  MOVWF  07
03D4:  BCF    03.5
03D5:  BCF    07.0
.................... output_low(salida02); 
03D6:  BSF    03.5
03D7:  BCF    6F.1
03D8:  MOVF   6F,W
03D9:  MOVWF  07
03DA:  BCF    03.5
03DB:  BCF    07.1
.................... output_low(salida03); 
03DC:  BSF    03.5
03DD:  BCF    6F.2
03DE:  MOVF   6F,W
03DF:  MOVWF  07
03E0:  BCF    03.5
03E1:  BCF    07.2
.................... output_low(salida04); 
03E2:  BSF    03.5
03E3:  BCF    6F.5
03E4:  MOVF   6F,W
03E5:  MOVWF  07
03E6:  BCF    03.5
03E7:  BCF    07.5
.................... while(true){ 
.................... ////////////////// 
....................  if( (apagarA)&&(time_apagarA>=25) ) { 
03E8:  MOVF   35,F
03E9:  BTFSC  03.2
03EA:  GOTO   3F4
03EB:  MOVF   36,W
03EC:  SUBLW  18
03ED:  BTFSC  03.0
03EE:  GOTO   3F4
....................    apagarA=0; 
03EF:  CLRF   35
....................    output_low(indicadorA); 
03F0:  BSF    03.5
03F1:  BCF    08.2
03F2:  BCF    03.5
03F3:  BCF    08.2
....................  } 
....................  if( (apagarB)&&(time_apagarB>=25) ) { 
03F4:  MOVF   37,F
03F5:  BTFSC  03.2
03F6:  GOTO   400
03F7:  MOVF   38,W
03F8:  SUBLW  18
03F9:  BTFSC  03.0
03FA:  GOTO   400
....................    apagarB=0; 
03FB:  CLRF   37
....................    output_low(indicadorB); 
03FC:  BSF    03.5
03FD:  BCF    08.3
03FE:  BCF    03.5
03FF:  BCF    08.3
....................  } 
....................  if( (apagarC)&&(time_apagarC>=25) ) { 
0400:  MOVF   39,F
0401:  BTFSC  03.2
0402:  GOTO   40C
0403:  MOVF   3A,W
0404:  SUBLW  18
0405:  BTFSC  03.0
0406:  GOTO   40C
....................    apagarC=0; 
0407:  CLRF   39
....................    output_low(indicadorC); 
0408:  BSF    03.5
0409:  BCF    08.0
040A:  BCF    03.5
040B:  BCF    08.0
....................  } 
....................  if( (apagarD)&&(time_apagarD>=25) ) { 
040C:  MOVF   3B,F
040D:  BTFSC  03.2
040E:  GOTO   418
040F:  MOVF   3C,W
0410:  SUBLW  18
0411:  BTFSC  03.0
0412:  GOTO   418
....................    apagarD=0; 
0413:  CLRF   3B
....................    output_low(indicadorD); 
0414:  BSF    03.5
0415:  BCF    08.1
0416:  BCF    03.5
0417:  BCF    08.1
....................  } 
....................  wiegand_read_card(); 
0418:  BSF    0A.3
0419:  GOTO   000
041A:  BCF    0A.3
....................  for(i=0;i<4;i++) {//apaga luz roja (nip cancelado) 
041B:  CLRF   33
041C:  CLRF   32
041D:  MOVF   33,F
041E:  BTFSS  03.2
041F:  GOTO   47D
0420:  MOVF   32,W
0421:  SUBLW  03
0422:  BTFSS  03.0
0423:  GOTO   47D
....................    if( relay[i]&&(t_relay[i]>=6) ){ 
0424:  MOVLW  5C
0425:  ADDWF  32,W
0426:  MOVWF  04
0427:  BCF    03.7
0428:  BTFSC  33.0
0429:  BSF    03.7
042A:  MOVF   00,F
042B:  BTFSC  03.2
042C:  GOTO   479
042D:  MOVLW  60
042E:  ADDWF  32,W
042F:  MOVWF  04
0430:  BCF    03.7
0431:  BTFSC  33.0
0432:  BSF    03.7
0433:  MOVF   00,W
0434:  SUBLW  05
0435:  BTFSC  03.0
0436:  GOTO   479
....................       relay[i]=0; 
0437:  MOVLW  5C
0438:  ADDWF  32,W
0439:  MOVWF  04
043A:  BCF    03.7
043B:  BTFSC  33.0
043C:  BSF    03.7
043D:  CLRF   00
....................       switch(i){ 
043E:  MOVF   32,W
043F:  MOVWF  77
0440:  MOVF   33,W
0441:  MOVWF  7A
0442:  MOVF   7A,W
0443:  BTFSS  03.2
0444:  GOTO   448
0445:  MOVF   77,F
0446:  BTFSC  03.2
0447:  GOTO   45E
0448:  MOVF   7A,W
0449:  BTFSS  03.2
044A:  GOTO   44F
044B:  MOVLW  01
044C:  SUBWF  77,W
044D:  BTFSC  03.2
044E:  GOTO   465
044F:  MOVF   7A,W
0450:  BTFSS  03.2
0451:  GOTO   456
0452:  MOVLW  02
0453:  SUBWF  77,W
0454:  BTFSC  03.2
0455:  GOTO   46C
0456:  MOVF   7A,W
0457:  BTFSS  03.2
0458:  GOTO   45D
0459:  MOVLW  03
045A:  SUBWF  77,W
045B:  BTFSC  03.2
045C:  GOTO   473
045D:  GOTO   479
....................          case 0: output_low(salida01); 
045E:  BSF    03.5
045F:  BCF    6F.0
0460:  MOVF   6F,W
0461:  MOVWF  07
0462:  BCF    03.5
0463:  BCF    07.0
....................                  break; 
0464:  GOTO   479
....................          case 1: output_low(salida02); 
0465:  BSF    03.5
0466:  BCF    6F.1
0467:  MOVF   6F,W
0468:  MOVWF  07
0469:  BCF    03.5
046A:  BCF    07.1
....................                  break; 
046B:  GOTO   479
....................          case 2: output_low(salida03); 
046C:  BSF    03.5
046D:  BCF    6F.2
046E:  MOVF   6F,W
046F:  MOVWF  07
0470:  BCF    03.5
0471:  BCF    07.2
....................                  break; 
0472:  GOTO   479
....................          case 3: output_low(salida04); 
0473:  BSF    03.5
0474:  BCF    6F.5
0475:  MOVF   6F,W
0476:  MOVWF  07
0477:  BCF    03.5
0478:  BCF    07.5
....................                  break; 
....................       } 
....................    }// 
0479:  INCF   32,F
047A:  BTFSC  03.2
047B:  INCF   33,F
047C:  GOTO   41D
....................  }//end for 
....................  
....................  for(i=0;i<4;i++) {//12.5=1seg. 
047D:  CLRF   33
047E:  CLRF   32
047F:  MOVF   33,F
0480:  BTFSS  03.2
0481:  GOTO   50E
0482:  MOVF   32,W
0483:  SUBLW  03
0484:  BTFSS  03.0
0485:  GOTO   50E
....................    if( f_nip[i]&&(time_nip[i])>50){ 
0486:  MOVLW  53
0487:  ADDWF  32,W
0488:  MOVWF  04
0489:  BCF    03.7
048A:  BTFSC  33.0
048B:  BSF    03.7
048C:  MOVF   00,F
048D:  BTFSC  03.2
048E:  GOTO   50A
048F:  MOVLW  4F
0490:  ADDWF  32,W
0491:  MOVWF  04
0492:  BCF    03.7
0493:  BTFSC  33.0
0494:  BSF    03.7
0495:  MOVF   00,W
0496:  SUBLW  32
0497:  BTFSC  03.0
0498:  GOTO   50A
....................       relay[i]=1; 
0499:  MOVLW  5C
049A:  ADDWF  32,W
049B:  MOVWF  04
049C:  BCF    03.7
049D:  BTFSC  33.0
049E:  BSF    03.7
049F:  MOVLW  01
04A0:  MOVWF  00
....................       t_relay[i]=0; 
04A1:  MOVLW  60
04A2:  ADDWF  32,W
04A3:  MOVWF  04
04A4:  BCF    03.7
04A5:  BTFSC  33.0
04A6:  BSF    03.7
04A7:  CLRF   00
....................       f_nip[i]=0; 
04A8:  MOVLW  53
04A9:  ADDWF  32,W
04AA:  MOVWF  04
04AB:  BCF    03.7
04AC:  BTFSC  33.0
04AD:  BSF    03.7
04AE:  CLRF   00
....................       switch(i){ 
04AF:  MOVF   32,W
04B0:  MOVWF  77
04B1:  MOVF   33,W
04B2:  MOVWF  7A
04B3:  MOVF   7A,W
04B4:  BTFSS  03.2
04B5:  GOTO   4B9
04B6:  MOVF   77,F
04B7:  BTFSC  03.2
04B8:  GOTO   4CF
04B9:  MOVF   7A,W
04BA:  BTFSS  03.2
04BB:  GOTO   4C0
04BC:  MOVLW  01
04BD:  SUBWF  77,W
04BE:  BTFSC  03.2
04BF:  GOTO   4DE
04C0:  MOVF   7A,W
04C1:  BTFSS  03.2
04C2:  GOTO   4C7
04C3:  MOVLW  02
04C4:  SUBWF  77,W
04C5:  BTFSC  03.2
04C6:  GOTO   4ED
04C7:  MOVF   7A,W
04C8:  BTFSS  03.2
04C9:  GOTO   4CE
04CA:  MOVLW  03
04CB:  SUBWF  77,W
04CC:  BTFSC  03.2
04CD:  GOTO   4FC
04CE:  GOTO   50A
....................          case 0: memset(nipA, 0, sizeof(nipA)); 
04CF:  MOVLW  3F
04D0:  MOVWF  04
04D1:  BCF    03.7
04D2:  CLRF   77
04D3:  MOVLW  04
04D4:  MOVWF  78
04D5:  CALL   1BC
....................                  ia=0; 
04D6:  CLRF   57
....................                  output_high(salida01); 
04D7:  BSF    03.5
04D8:  BCF    6F.0
04D9:  MOVF   6F,W
04DA:  MOVWF  07
04DB:  BCF    03.5
04DC:  BSF    07.0
....................                  break; 
04DD:  GOTO   50A
....................          case 1: memset(nipB, 0, sizeof(nipB)); 
04DE:  MOVLW  43
04DF:  MOVWF  04
04E0:  BCF    03.7
04E1:  CLRF   77
04E2:  MOVLW  04
04E3:  MOVWF  78
04E4:  CALL   1BC
....................                  ib=0; 
04E5:  CLRF   58
....................                  output_high(salida02); 
04E6:  BSF    03.5
04E7:  BCF    6F.1
04E8:  MOVF   6F,W
04E9:  MOVWF  07
04EA:  BCF    03.5
04EB:  BSF    07.1
....................                  break; 
04EC:  GOTO   50A
....................          case 2: memset(nipC, 0, sizeof(nipC)); 
04ED:  MOVLW  47
04EE:  MOVWF  04
04EF:  BCF    03.7
04F0:  CLRF   77
04F1:  MOVLW  04
04F2:  MOVWF  78
04F3:  CALL   1BC
....................                  ic=0; 
04F4:  CLRF   59
....................                  output_high(salida03); 
04F5:  BSF    03.5
04F6:  BCF    6F.2
04F7:  MOVF   6F,W
04F8:  MOVWF  07
04F9:  BCF    03.5
04FA:  BSF    07.2
....................                  break; 
04FB:  GOTO   50A
....................          case 3: memset(nipD, 0, sizeof(nipD)); 
04FC:  MOVLW  4B
04FD:  MOVWF  04
04FE:  BCF    03.7
04FF:  CLRF   77
0500:  MOVLW  04
0501:  MOVWF  78
0502:  CALL   1BC
....................                  id=0; 
0503:  CLRF   5A
....................                  output_high(salida04); 
0504:  BSF    03.5
0505:  BCF    6F.5
0506:  MOVF   6F,W
0507:  MOVWF  07
0508:  BCF    03.5
0509:  BSF    07.5
....................                  break; 
....................       }// 
....................    }//end tiempo 
050A:  INCF   32,F
050B:  BTFSC  03.2
050C:  INCF   33,F
050D:  GOTO   47F
....................  }//end 4seg. 
....................  restart_wdt(); 
050E:  CLRWDT
050F:  GOTO   3E8
....................  }//fin while true 
.................... }//fin main 
....................  
0510:  SLEEP
.................... void wiegand_read_card(){ 
....................  if( (wieg_a==1)&&(wiegand_cuenta_a>=2) ) { 
*
0800:  DECFSZ 64,W
0801:  GOTO   17B
0802:  MOVF   67,W
0803:  SUBLW  01
0804:  BTFSC  03.0
0805:  GOTO   17B
....................    disable_interrupts(GLOBAL);//Deshabilito las interrupciones globales 
0806:  BCF    0B.6
0807:  BCF    0B.7
0808:  BTFSC  0B.7
0809:  GOTO   007
.................... //!   printf("\r\nTipo:W%u ",sub_indice_a); 
....................    wieg_full_a=0; 
080A:  CLRF   66
....................    deci_a=0; 
080B:  CLRF   6B
080C:  CLRF   6A
080D:  CLRF   69
080E:  CLRF   68
....................     
....................    if( (sub_indice_a==26)||(sub_indice_a==34) ){ 
080F:  MOVF   65,W
0810:  SUBLW  1A
0811:  BTFSC  03.2
0812:  GOTO   017
0813:  MOVF   65,W
0814:  SUBLW  22
0815:  BTFSS  03.2
0816:  GOTO   091
....................       for(i=1;i<sub_indice_a-1;i++) deci_a = (deci_a<<1)|data_a[i]; 
0817:  CLRF   33
0818:  MOVLW  01
0819:  MOVWF  32
081A:  MOVLW  01
081B:  SUBWF  65,W
081C:  MOVF   33,F
081D:  BTFSS  03.2
081E:  GOTO   04E
081F:  SUBWF  32,W
0820:  BTFSC  03.0
0821:  GOTO   04E
0822:  BCF    03.0
0823:  RLF    68,W
0824:  BSF    03.6
0825:  MOVWF  59
0826:  BCF    03.6
0827:  RLF    69,W
0828:  BSF    03.6
0829:  MOVWF  5A
082A:  BCF    03.6
082B:  RLF    6A,W
082C:  BSF    03.6
082D:  MOVWF  5B
082E:  BCF    03.6
082F:  RLF    6B,W
0830:  BSF    03.6
0831:  MOVWF  5C
0832:  MOVLW  A0
0833:  BCF    03.6
0834:  ADDWF  32,W
0835:  MOVWF  04
0836:  BCF    03.7
0837:  BTFSC  33.0
0838:  BSF    03.7
0839:  MOVF   00,W
083A:  BSF    03.6
083B:  IORWF  59,W
083C:  BCF    03.6
083D:  MOVWF  68
083E:  BSF    03.6
083F:  MOVF   5A,W
0840:  BCF    03.6
0841:  MOVWF  69
0842:  BSF    03.6
0843:  MOVF   5B,W
0844:  BCF    03.6
0845:  MOVWF  6A
0846:  BSF    03.6
0847:  MOVF   5C,W
0848:  BCF    03.6
0849:  MOVWF  6B
084A:  INCF   32,F
084B:  BTFSC  03.2
084C:  INCF   33,F
084D:  GOTO   01A
....................       printf("MUXA-IDX:%08LX\r",deci_a); 
084E:  MOVLW  74
084F:  BSF    03.6
0850:  MOVWF  0D
0851:  MOVLW  01
0852:  MOVWF  0F
0853:  BCF    03.0
0854:  MOVLW  09
0855:  MOVWF  58
0856:  BCF    0A.3
0857:  BCF    03.6
0858:  CALL   1C5
0859:  BSF    0A.3
085A:  MOVF   6B,W
085B:  BSF    03.6
085C:  MOVWF  58
085D:  MOVLW  37
085E:  MOVWF  59
085F:  BCF    0A.3
0860:  BCF    03.6
0861:  CALL   21B
0862:  BSF    0A.3
0863:  MOVF   6A,W
0864:  BSF    03.6
0865:  MOVWF  58
0866:  MOVLW  37
0867:  MOVWF  59
0868:  BCF    0A.3
0869:  BCF    03.6
086A:  CALL   21B
086B:  BSF    0A.3
086C:  MOVF   69,W
086D:  BSF    03.6
086E:  MOVWF  58
086F:  MOVLW  37
0870:  MOVWF  59
0871:  BCF    0A.3
0872:  BCF    03.6
0873:  CALL   21B
0874:  BSF    0A.3
0875:  MOVF   68,W
0876:  BSF    03.6
0877:  MOVWF  58
0878:  MOVLW  37
0879:  MOVWF  59
087A:  BCF    0A.3
087B:  BCF    03.6
087C:  CALL   21B
087D:  BSF    0A.3
087E:  MOVLW  0D
087F:  BTFSS  0C.4
0880:  GOTO   07F
0881:  MOVWF  19
....................       apagarA=1; 
0882:  MOVLW  01
0883:  MOVWF  35
....................       time_apagarA=0; 
0884:  CLRF   36
....................       memset(nipA, 0, sizeof(nipA)); 
0885:  MOVLW  3F
0886:  MOVWF  04
0887:  BCF    03.7
0888:  CLRF   77
0889:  MOVLW  04
088A:  MOVWF  78
088B:  BCF    0A.3
088C:  CALL   1BC
088D:  BSF    0A.3
....................       ia=0; 
088E:  CLRF   57
....................       f_nip[0]=0; 
088F:  CLRF   53
....................    } 
0890:  GOTO   165
....................    else if ((sub_indice_a==8)||(sub_indice_a==4) ) { //printf("Tecla:"); 
0891:  MOVF   65,W
0892:  SUBLW  08
0893:  BTFSC  03.2
0894:  GOTO   099
0895:  MOVF   65,W
0896:  SUBLW  04
0897:  BTFSS  03.2
0898:  GOTO   15C
....................          apagarA=0; 
0899:  CLRF   35
....................          output_low(indicadorA); 
089A:  BSF    03.5
089B:  BCF    08.2
089C:  BCF    03.5
089D:  BCF    08.2
....................          if(sub_indice_a==4) for(i=0;i<sub_indice_a;i++) deci_a = (deci_a<<1)|data_a[i]; 
089E:  MOVF   65,W
089F:  SUBLW  04
08A0:  BTFSS  03.2
08A1:  GOTO   0D8
08A2:  CLRF   33
08A3:  CLRF   32
08A4:  MOVF   33,F
08A5:  BTFSS  03.2
08A6:  GOTO   0D7
08A7:  MOVF   65,W
08A8:  SUBWF  32,W
08A9:  BTFSC  03.0
08AA:  GOTO   0D7
08AB:  BCF    03.0
08AC:  RLF    68,W
08AD:  BSF    03.6
08AE:  MOVWF  59
08AF:  BCF    03.6
08B0:  RLF    69,W
08B1:  BSF    03.6
08B2:  MOVWF  5A
08B3:  BCF    03.6
08B4:  RLF    6A,W
08B5:  BSF    03.6
08B6:  MOVWF  5B
08B7:  BCF    03.6
08B8:  RLF    6B,W
08B9:  BSF    03.6
08BA:  MOVWF  5C
08BB:  MOVLW  A0
08BC:  BCF    03.6
08BD:  ADDWF  32,W
08BE:  MOVWF  04
08BF:  BCF    03.7
08C0:  BTFSC  33.0
08C1:  BSF    03.7
08C2:  MOVF   00,W
08C3:  BSF    03.6
08C4:  IORWF  59,W
08C5:  BCF    03.6
08C6:  MOVWF  68
08C7:  BSF    03.6
08C8:  MOVF   5A,W
08C9:  BCF    03.6
08CA:  MOVWF  69
08CB:  BSF    03.6
08CC:  MOVF   5B,W
08CD:  BCF    03.6
08CE:  MOVWF  6A
08CF:  BSF    03.6
08D0:  MOVF   5C,W
08D1:  BCF    03.6
08D2:  MOVWF  6B
08D3:  INCF   32,F
08D4:  BTFSC  03.2
08D5:  INCF   33,F
08D6:  GOTO   0A4
08D7:  GOTO   10E
....................          else for(i=4;i<sub_indice_a;i++) deci_a = (deci_a<<1)|data_a[i]; 
08D8:  CLRF   33
08D9:  MOVLW  04
08DA:  MOVWF  32
08DB:  MOVF   33,F
08DC:  BTFSS  03.2
08DD:  GOTO   10E
08DE:  MOVF   65,W
08DF:  SUBWF  32,W
08E0:  BTFSC  03.0
08E1:  GOTO   10E
08E2:  BCF    03.0
08E3:  RLF    68,W
08E4:  BSF    03.6
08E5:  MOVWF  59
08E6:  BCF    03.6
08E7:  RLF    69,W
08E8:  BSF    03.6
08E9:  MOVWF  5A
08EA:  BCF    03.6
08EB:  RLF    6A,W
08EC:  BSF    03.6
08ED:  MOVWF  5B
08EE:  BCF    03.6
08EF:  RLF    6B,W
08F0:  BSF    03.6
08F1:  MOVWF  5C
08F2:  MOVLW  A0
08F3:  BCF    03.6
08F4:  ADDWF  32,W
08F5:  MOVWF  04
08F6:  BCF    03.7
08F7:  BTFSC  33.0
08F8:  BSF    03.7
08F9:  MOVF   00,W
08FA:  BSF    03.6
08FB:  IORWF  59,W
08FC:  BCF    03.6
08FD:  MOVWF  68
08FE:  BSF    03.6
08FF:  MOVF   5A,W
0900:  BCF    03.6
0901:  MOVWF  69
0902:  BSF    03.6
0903:  MOVF   5B,W
0904:  BCF    03.6
0905:  MOVWF  6A
0906:  BSF    03.6
0907:  MOVF   5C,W
0908:  BCF    03.6
0909:  MOVWF  6B
090A:  INCF   32,F
090B:  BTFSC  03.2
090C:  INCF   33,F
090D:  GOTO   0DB
....................          nipA[ia]=deci_a; 
090E:  MOVLW  3F
090F:  ADDWF  57,W
0910:  MOVWF  04
0911:  BCF    03.7
0912:  MOVF   68,W
0913:  MOVWF  00
....................          f_nip[0]=1; 
0914:  MOVLW  01
0915:  MOVWF  53
....................          time_nip[0]=0; 
0916:  CLRF   4F
....................          ia++; 
0917:  INCF   57,F
....................          if(ia==4) { 
0918:  MOVF   57,W
0919:  SUBLW  04
091A:  BTFSS  03.2
091B:  GOTO   15B
....................             printf("MUXB-NIP:%u%u%u%u\r",nipA[0],nipA[1],nipA[2],nipA[3]);//MUXA-IDX:00C4DA5D 
091C:  MOVLW  7C
091D:  BSF    03.6
091E:  MOVWF  0D
091F:  MOVLW  01
0920:  MOVWF  0F
0921:  BCF    03.0
0922:  MOVLW  09
0923:  MOVWF  58
0924:  BCF    0A.3
0925:  BCF    03.6
0926:  CALL   1C5
0927:  BSF    0A.3
0928:  MOVF   3F,W
0929:  BSF    03.6
092A:  MOVWF  58
092B:  MOVLW  1B
092C:  MOVWF  59
092D:  BCF    0A.3
092E:  BCF    03.6
092F:  CALL   259
0930:  BSF    0A.3
0931:  MOVF   40,W
0932:  BSF    03.6
0933:  MOVWF  58
0934:  MOVLW  1B
0935:  MOVWF  59
0936:  BCF    0A.3
0937:  BCF    03.6
0938:  CALL   259
0939:  BSF    0A.3
093A:  MOVF   41,W
093B:  BSF    03.6
093C:  MOVWF  58
093D:  MOVLW  1B
093E:  MOVWF  59
093F:  BCF    0A.3
0940:  BCF    03.6
0941:  CALL   259
0942:  BSF    0A.3
0943:  MOVF   42,W
0944:  BSF    03.6
0945:  MOVWF  58
0946:  MOVLW  1B
0947:  MOVWF  59
0948:  BCF    0A.3
0949:  BCF    03.6
094A:  CALL   259
094B:  BSF    0A.3
094C:  MOVLW  0D
094D:  BTFSS  0C.4
094E:  GOTO   14D
094F:  MOVWF  19
....................             memset(nipA, 0, sizeof(nipA)); 
0950:  MOVLW  3F
0951:  MOVWF  04
0952:  BCF    03.7
0953:  CLRF   77
0954:  MOVLW  04
0955:  MOVWF  78
0956:  BCF    0A.3
0957:  CALL   1BC
0958:  BSF    0A.3
....................             ia=0; 
0959:  CLRF   57
....................             f_nip[0]=0; 
095A:  CLRF   53
....................          } 
....................    } 
095B:  GOTO   165
....................    else { 
.................... //!         printf("Error de Lectura:"); 
....................          disable_interrupts(GLOBAL);//Deshabilito las interrupciones globales 
095C:  BCF    0B.6
095D:  BCF    0B.7
095E:  BTFSC  0B.7
095F:  GOTO   15D
....................          apagarA=0; 
0960:  CLRF   35
....................          output_low(indicadorA); 
0961:  BSF    03.5
0962:  BCF    08.2
0963:  BCF    03.5
0964:  BCF    08.2
.................... //!         for(i=0;i<sub_indice_a;i++) printf("%u",data_a[i]); 
....................    } 
....................    deci_a=0; 
0965:  CLRF   6B
0966:  CLRF   6A
0967:  CLRF   69
0968:  CLRF   68
....................    deteccion_nulo_a=0; 
0969:  CLRF   3D
....................    pre_cuenta_a=0; 
096A:  CLRF   3E
....................    wieg_a=sub_indice_a=i=0; 
096B:  CLRF   33
096C:  CLRF   32
096D:  MOVF   32,W
096E:  MOVWF  65
096F:  MOVWF  64
....................    //for(i=0;i<wieg_size;i++) data_a[i]=0; 
....................    memset(data_a, 0, sizeof(data_a) ); 
0970:  MOVLW  A0
0971:  MOVWF  04
0972:  BCF    03.7
0973:  CLRF   77
0974:  MOVLW  22
0975:  MOVWF  78
0976:  BCF    0A.3
0977:  CALL   1BC
0978:  BSF    0A.3
....................    enable_interrupts(GLOBAL); 
0979:  MOVLW  C0
097A:  IORWF  0B,F
....................  }//END TARJETA LEIDA 
....................  ////// 
....................  if( (wieg_b==1)&&(wiegand_cuenta_b>=2) ) { 
097B:  DECFSZ 6E,W
097C:  GOTO   2DB
097D:  MOVF   71,W
097E:  SUBLW  01
097F:  BTFSC  03.0
0980:  GOTO   2DB
....................    disable_interrupts(GLOBAL);//Deshabilito las interrupciones globales 
0981:  BCF    0B.6
0982:  BCF    0B.7
0983:  BTFSC  0B.7
0984:  GOTO   182
.................... //!   printf("\r\nTipo:W%u ",sub_indice_b); 
....................    wieg_full_b=0; 
0985:  CLRF   70
....................    deci_b=0; 
0986:  CLRF   75
0987:  CLRF   74
0988:  CLRF   73
0989:  CLRF   72
....................     
....................    if( (sub_indice_b==26)||(sub_indice_b==34) ){ 
098A:  MOVF   6F,W
098B:  SUBLW  1A
098C:  BTFSC  03.2
098D:  GOTO   192
098E:  MOVF   6F,W
098F:  SUBLW  22
0990:  BTFSS  03.2
0991:  GOTO   1FF
....................       for(i=1;i<sub_indice_b-1;i++) deci_b = (deci_b<<1)|data_b[i]; 
0992:  CLRF   33
0993:  MOVLW  01
0994:  MOVWF  32
0995:  MOVLW  01
0996:  SUBWF  6F,W
0997:  MOVF   33,F
0998:  BTFSS  03.2
0999:  GOTO   1BD
099A:  SUBWF  32,W
099B:  BTFSC  03.0
099C:  GOTO   1BD
099D:  BCF    03.0
099E:  RLF    72,W
099F:  BSF    03.6
09A0:  MOVWF  59
09A1:  RLF    73,W
09A2:  MOVWF  5A
09A3:  RLF    74,W
09A4:  MOVWF  5B
09A5:  RLF    75,W
09A6:  MOVWF  5C
09A7:  MOVLW  C2
09A8:  BCF    03.6
09A9:  ADDWF  32,W
09AA:  MOVWF  04
09AB:  BCF    03.7
09AC:  BTFSC  33.0
09AD:  BSF    03.7
09AE:  MOVF   00,W
09AF:  BSF    03.6
09B0:  IORWF  59,W
09B1:  MOVWF  72
09B2:  MOVF   5A,W
09B3:  MOVWF  73
09B4:  MOVF   5B,W
09B5:  MOVWF  74
09B6:  MOVF   5C,W
09B7:  MOVWF  75
09B8:  BCF    03.6
09B9:  INCF   32,F
09BA:  BTFSC  03.2
09BB:  INCF   33,F
09BC:  GOTO   195
....................       printf("MUXB-IDX:%08LX\r",deci_b); 
09BD:  MOVLW  86
09BE:  BSF    03.6
09BF:  MOVWF  0D
09C0:  MOVLW  01
09C1:  MOVWF  0F
09C2:  BCF    03.0
09C3:  MOVLW  09
09C4:  MOVWF  58
09C5:  BCF    0A.3
09C6:  BCF    03.6
09C7:  CALL   1C5
09C8:  BSF    0A.3
09C9:  MOVF   75,W
09CA:  BSF    03.6
09CB:  MOVWF  58
09CC:  MOVLW  37
09CD:  MOVWF  59
09CE:  BCF    0A.3
09CF:  BCF    03.6
09D0:  CALL   21B
09D1:  BSF    0A.3
09D2:  MOVF   74,W
09D3:  BSF    03.6
09D4:  MOVWF  58
09D5:  MOVLW  37
09D6:  MOVWF  59
09D7:  BCF    0A.3
09D8:  BCF    03.6
09D9:  CALL   21B
09DA:  BSF    0A.3
09DB:  MOVF   73,W
09DC:  BSF    03.6
09DD:  MOVWF  58
09DE:  MOVLW  37
09DF:  MOVWF  59
09E0:  BCF    0A.3
09E1:  BCF    03.6
09E2:  CALL   21B
09E3:  BSF    0A.3
09E4:  MOVF   72,W
09E5:  BSF    03.6
09E6:  MOVWF  58
09E7:  MOVLW  37
09E8:  MOVWF  59
09E9:  BCF    0A.3
09EA:  BCF    03.6
09EB:  CALL   21B
09EC:  BSF    0A.3
09ED:  MOVLW  0D
09EE:  BTFSS  0C.4
09EF:  GOTO   1EE
09F0:  MOVWF  19
....................       apagarB=1; 
09F1:  MOVLW  01
09F2:  MOVWF  37
....................       time_apagarB=0; 
09F3:  CLRF   38
....................       memset(nipB, 0, sizeof(nipB)); 
09F4:  MOVLW  43
09F5:  MOVWF  04
09F6:  BCF    03.7
09F7:  CLRF   77
09F8:  MOVLW  04
09F9:  MOVWF  78
09FA:  BCF    0A.3
09FB:  CALL   1BC
09FC:  BSF    0A.3
....................       ib=0; 
09FD:  CLRF   58
....................    } 
09FE:  GOTO   2C5
....................    else if ( (sub_indice_b==8)||(sub_indice_b==4) ) { 
09FF:  MOVF   6F,W
0A00:  SUBLW  08
0A01:  BTFSC  03.2
0A02:  GOTO   207
0A03:  MOVF   6F,W
0A04:  SUBLW  04
0A05:  BTFSS  03.2
0A06:  GOTO   2B2
.................... //!         printf("Tecla:"); 
....................          apagarB=0; 
0A07:  CLRF   37
....................          output_low(indicadorB); 
0A08:  BSF    03.5
0A09:  BCF    08.3
0A0A:  BCF    03.5
0A0B:  BCF    08.3
....................          if(sub_indice_b==8) for(i=4;i<sub_indice_b;i++) deci_b = (deci_b<<1)|data_b[i]; 
0A0C:  MOVF   6F,W
0A0D:  SUBLW  08
0A0E:  BTFSS  03.2
0A0F:  GOTO   23B
0A10:  CLRF   33
0A11:  MOVLW  04
0A12:  MOVWF  32
0A13:  MOVF   33,F
0A14:  BTFSS  03.2
0A15:  GOTO   23A
0A16:  MOVF   6F,W
0A17:  SUBWF  32,W
0A18:  BTFSC  03.0
0A19:  GOTO   23A
0A1A:  BCF    03.0
0A1B:  RLF    72,W
0A1C:  BSF    03.6
0A1D:  MOVWF  59
0A1E:  RLF    73,W
0A1F:  MOVWF  5A
0A20:  RLF    74,W
0A21:  MOVWF  5B
0A22:  RLF    75,W
0A23:  MOVWF  5C
0A24:  MOVLW  C2
0A25:  BCF    03.6
0A26:  ADDWF  32,W
0A27:  MOVWF  04
0A28:  BCF    03.7
0A29:  BTFSC  33.0
0A2A:  BSF    03.7
0A2B:  MOVF   00,W
0A2C:  BSF    03.6
0A2D:  IORWF  59,W
0A2E:  MOVWF  72
0A2F:  MOVF   5A,W
0A30:  MOVWF  73
0A31:  MOVF   5B,W
0A32:  MOVWF  74
0A33:  MOVF   5C,W
0A34:  MOVWF  75
0A35:  BCF    03.6
0A36:  INCF   32,F
0A37:  BTFSC  03.2
0A38:  INCF   33,F
0A39:  GOTO   213
0A3A:  GOTO   264
....................          else for(i=0;i<sub_indice_b;i++) deci_b = (deci_b<<1)|data_b[i]; 
0A3B:  CLRF   33
0A3C:  CLRF   32
0A3D:  MOVF   33,F
0A3E:  BTFSS  03.2
0A3F:  GOTO   264
0A40:  MOVF   6F,W
0A41:  SUBWF  32,W
0A42:  BTFSC  03.0
0A43:  GOTO   264
0A44:  BCF    03.0
0A45:  RLF    72,W
0A46:  BSF    03.6
0A47:  MOVWF  59
0A48:  RLF    73,W
0A49:  MOVWF  5A
0A4A:  RLF    74,W
0A4B:  MOVWF  5B
0A4C:  RLF    75,W
0A4D:  MOVWF  5C
0A4E:  MOVLW  C2
0A4F:  BCF    03.6
0A50:  ADDWF  32,W
0A51:  MOVWF  04
0A52:  BCF    03.7
0A53:  BTFSC  33.0
0A54:  BSF    03.7
0A55:  MOVF   00,W
0A56:  BSF    03.6
0A57:  IORWF  59,W
0A58:  MOVWF  72
0A59:  MOVF   5A,W
0A5A:  MOVWF  73
0A5B:  MOVF   5B,W
0A5C:  MOVWF  74
0A5D:  MOVF   5C,W
0A5E:  MOVWF  75
0A5F:  BCF    03.6
0A60:  INCF   32,F
0A61:  BTFSC  03.2
0A62:  INCF   33,F
0A63:  GOTO   23D
....................          nipB[ib]=deci_b; 
0A64:  MOVLW  43
0A65:  ADDWF  58,W
0A66:  MOVWF  04
0A67:  BCF    03.7
0A68:  MOVF   72,W
0A69:  MOVWF  00
....................          f_nip[1]=1; 
0A6A:  MOVLW  01
0A6B:  MOVWF  54
....................          time_nip[1]=0; 
0A6C:  CLRF   50
....................          ib++; 
0A6D:  INCF   58,F
....................          if(ib==4) { 
0A6E:  MOVF   58,W
0A6F:  SUBLW  04
0A70:  BTFSS  03.2
0A71:  GOTO   2B1
....................             printf("MUXA-NIP:%u%u%u%u\r",nipB[0],nipB[1],nipB[2],nipB[3]);//MUXA-IDX:00C4DA5D 
0A72:  MOVLW  8E
0A73:  BSF    03.6
0A74:  MOVWF  0D
0A75:  MOVLW  01
0A76:  MOVWF  0F
0A77:  BCF    03.0
0A78:  MOVLW  09
0A79:  MOVWF  58
0A7A:  BCF    0A.3
0A7B:  BCF    03.6
0A7C:  CALL   1C5
0A7D:  BSF    0A.3
0A7E:  MOVF   43,W
0A7F:  BSF    03.6
0A80:  MOVWF  58
0A81:  MOVLW  1B
0A82:  MOVWF  59
0A83:  BCF    0A.3
0A84:  BCF    03.6
0A85:  CALL   259
0A86:  BSF    0A.3
0A87:  MOVF   44,W
0A88:  BSF    03.6
0A89:  MOVWF  58
0A8A:  MOVLW  1B
0A8B:  MOVWF  59
0A8C:  BCF    0A.3
0A8D:  BCF    03.6
0A8E:  CALL   259
0A8F:  BSF    0A.3
0A90:  MOVF   45,W
0A91:  BSF    03.6
0A92:  MOVWF  58
0A93:  MOVLW  1B
0A94:  MOVWF  59
0A95:  BCF    0A.3
0A96:  BCF    03.6
0A97:  CALL   259
0A98:  BSF    0A.3
0A99:  MOVF   46,W
0A9A:  BSF    03.6
0A9B:  MOVWF  58
0A9C:  MOVLW  1B
0A9D:  MOVWF  59
0A9E:  BCF    0A.3
0A9F:  BCF    03.6
0AA0:  CALL   259
0AA1:  BSF    0A.3
0AA2:  MOVLW  0D
0AA3:  BTFSS  0C.4
0AA4:  GOTO   2A3
0AA5:  MOVWF  19
....................             memset(nipB, 0, sizeof(nipB)); 
0AA6:  MOVLW  43
0AA7:  MOVWF  04
0AA8:  BCF    03.7
0AA9:  CLRF   77
0AAA:  MOVLW  04
0AAB:  MOVWF  78
0AAC:  BCF    0A.3
0AAD:  CALL   1BC
0AAE:  BSF    0A.3
....................             ib=0; 
0AAF:  CLRF   58
....................             f_nip[1]=0; 
0AB0:  CLRF   54
....................          } 
.................... //!         printf("%Lu-B\r",deci_b); 
....................    } 
0AB1:  GOTO   2C5
....................    else { 
.................... //!         printf("Error de Lectura:"); 
....................          disable_interrupts(GLOBAL);//Deshabilito las interrupciones globales 
0AB2:  BCF    0B.6
0AB3:  BCF    0B.7
0AB4:  BTFSC  0B.7
0AB5:  GOTO   2B3
....................          apagarB=0; 
0AB6:  CLRF   37
....................          output_low(indicadorB); 
0AB7:  BSF    03.5
0AB8:  BCF    08.3
0AB9:  BCF    03.5
0ABA:  BCF    08.3
....................          memset(nipB, 0, sizeof(nipB)); 
0ABB:  MOVLW  43
0ABC:  MOVWF  04
0ABD:  BCF    03.7
0ABE:  CLRF   77
0ABF:  MOVLW  04
0AC0:  MOVWF  78
0AC1:  BCF    0A.3
0AC2:  CALL   1BC
0AC3:  BSF    0A.3
....................          ib=0; 
0AC4:  CLRF   58
.................... //!         for(i=0;i<sub_indice_b;i++) printf("%u",data_b[i]); 
....................    } 
....................    deci_b=0; 
0AC5:  CLRF   75
0AC6:  CLRF   74
0AC7:  CLRF   73
0AC8:  CLRF   72
....................    deteccion_nulo_b=0; 
0AC9:  CLRF   6C
....................    pre_cuenta_b=0; 
0ACA:  CLRF   6D
....................    wieg_b=sub_indice_b=i=0; 
0ACB:  CLRF   33
0ACC:  CLRF   32
0ACD:  MOVF   32,W
0ACE:  MOVWF  6F
0ACF:  MOVWF  6E
....................    //for(i=0;i<wieg_size;i++) data_a[i]=0; 
....................    memset(data_b, 0, sizeof(data_b) ); 
0AD0:  MOVLW  C2
0AD1:  MOVWF  04
0AD2:  BCF    03.7
0AD3:  CLRF   77
0AD4:  MOVLW  22
0AD5:  MOVWF  78
0AD6:  BCF    0A.3
0AD7:  CALL   1BC
0AD8:  BSF    0A.3
....................    enable_interrupts(GLOBAL); 
0AD9:  MOVLW  C0
0ADA:  IORWF  0B,F
....................  }//END TARJETA LEIDA 
....................  ////// 
....................  if( (wieg_c==1)&&(wiegand_cuenta_c>=2) ) { 
0ADB:  DECFSZ 7C,W
0ADC:  GOTO   48C
0ADD:  BSF    03.5
0ADE:  MOVF   64,W
0ADF:  SUBLW  01
0AE0:  BTFSS  03.0
0AE1:  GOTO   2E4
0AE2:  BCF    03.5
0AE3:  GOTO   48C
....................    disable_interrupts(GLOBAL);//Deshabilito las interrupciones globales 
0AE4:  BCF    03.5
0AE5:  BCF    0B.6
0AE6:  BCF    0B.7
0AE7:  BTFSC  0B.7
0AE8:  GOTO   2E6
.................... //!   printf("\r\nTipo:W%u ",sub_indice_c); 
....................    wieg_full_c=0; 
0AE9:  CLRF   7E
....................    deci_c=0; 
0AEA:  BSF    03.5
0AEB:  CLRF   68
0AEC:  CLRF   67
0AED:  CLRF   66
0AEE:  CLRF   65
....................     
....................    if( (sub_indice_c==26)||(sub_indice_c==34) ){ 
0AEF:  MOVF   7D,W
0AF0:  SUBLW  1A
0AF1:  BTFSC  03.2
0AF2:  GOTO   2F7
0AF3:  MOVF   7D,W
0AF4:  SUBLW  22
0AF5:  BTFSS  03.2
0AF6:  GOTO   37F
....................       for(i=1;i<sub_indice_c-1;i++) deci_c = (deci_c<<1)|data_c[i]; 
0AF7:  BCF    03.5
0AF8:  CLRF   33
0AF9:  MOVLW  01
0AFA:  MOVWF  32
0AFB:  MOVLW  01
0AFC:  SUBWF  7D,W
0AFD:  MOVF   33,F
0AFE:  BTFSS  03.2
0AFF:  GOTO   33D
0B00:  SUBWF  32,W
0B01:  BTFSC  03.0
0B02:  GOTO   33D
0B03:  BCF    03.0
0B04:  BSF    03.5
0B05:  RLF    65,W
0B06:  BCF    03.5
0B07:  BSF    03.6
0B08:  MOVWF  59
0B09:  BSF    03.5
0B0A:  BCF    03.6
0B0B:  RLF    66,W
0B0C:  BCF    03.5
0B0D:  BSF    03.6
0B0E:  MOVWF  5A
0B0F:  BSF    03.5
0B10:  BCF    03.6
0B11:  RLF    67,W
0B12:  BCF    03.5
0B13:  BSF    03.6
0B14:  MOVWF  5B
0B15:  BSF    03.5
0B16:  BCF    03.6
0B17:  RLF    68,W
0B18:  BCF    03.5
0B19:  BSF    03.6
0B1A:  MOVWF  5C
0B1B:  MOVLW  10
0B1C:  BCF    03.6
0B1D:  ADDWF  32,W
0B1E:  MOVWF  04
0B1F:  BSF    03.7
0B20:  MOVF   00,W
0B21:  BSF    03.6
0B22:  IORWF  59,W
0B23:  BSF    03.5
0B24:  BCF    03.6
0B25:  MOVWF  65
0B26:  BCF    03.5
0B27:  BSF    03.6
0B28:  MOVF   5A,W
0B29:  BSF    03.5
0B2A:  BCF    03.6
0B2B:  MOVWF  66
0B2C:  BCF    03.5
0B2D:  BSF    03.6
0B2E:  MOVF   5B,W
0B2F:  BSF    03.5
0B30:  BCF    03.6
0B31:  MOVWF  67
0B32:  BCF    03.5
0B33:  BSF    03.6
0B34:  MOVF   5C,W
0B35:  BSF    03.5
0B36:  BCF    03.6
0B37:  MOVWF  68
0B38:  BCF    03.5
0B39:  INCF   32,F
0B3A:  BTFSC  03.2
0B3B:  INCF   33,F
0B3C:  GOTO   2FB
....................       printf("MUXC-IDX:%08LX\r",deci_c); 
0B3D:  MOVLW  98
0B3E:  BSF    03.6
0B3F:  MOVWF  0D
0B40:  MOVLW  01
0B41:  MOVWF  0F
0B42:  BCF    03.0
0B43:  MOVLW  09
0B44:  MOVWF  58
0B45:  BCF    0A.3
0B46:  BCF    03.6
0B47:  CALL   1C5
0B48:  BSF    0A.3
0B49:  BSF    03.5
0B4A:  MOVF   68,W
0B4B:  BCF    03.5
0B4C:  BSF    03.6
0B4D:  MOVWF  58
0B4E:  MOVLW  37
0B4F:  MOVWF  59
0B50:  BCF    0A.3
0B51:  BCF    03.6
0B52:  CALL   21B
0B53:  BSF    0A.3
0B54:  BSF    03.5
0B55:  MOVF   67,W
0B56:  BCF    03.5
0B57:  BSF    03.6
0B58:  MOVWF  58
0B59:  MOVLW  37
0B5A:  MOVWF  59
0B5B:  BCF    0A.3
0B5C:  BCF    03.6
0B5D:  CALL   21B
0B5E:  BSF    0A.3
0B5F:  BSF    03.5
0B60:  MOVF   66,W
0B61:  BCF    03.5
0B62:  BSF    03.6
0B63:  MOVWF  58
0B64:  MOVLW  37
0B65:  MOVWF  59
0B66:  BCF    0A.3
0B67:  BCF    03.6
0B68:  CALL   21B
0B69:  BSF    0A.3
0B6A:  BSF    03.5
0B6B:  MOVF   65,W
0B6C:  BCF    03.5
0B6D:  BSF    03.6
0B6E:  MOVWF  58
0B6F:  MOVLW  37
0B70:  MOVWF  59
0B71:  BCF    0A.3
0B72:  BCF    03.6
0B73:  CALL   21B
0B74:  BSF    0A.3
0B75:  MOVLW  0D
0B76:  BTFSS  0C.4
0B77:  GOTO   376
0B78:  MOVWF  19
....................       apagarC=1; 
0B79:  MOVLW  01
0B7A:  MOVWF  39
....................       time_apagarC=0; 
0B7B:  CLRF   3A
....................       f_nip[2]=0; 
0B7C:  CLRF   55
....................    } 
0B7D:  GOTO   474
0B7E:  BSF    03.5
....................    else if ( (sub_indice_c==8)||(sub_indice_c==4) ) {//!         printf("Tecla:"); 
0B7F:  MOVF   7D,W
0B80:  SUBLW  08
0B81:  BTFSC  03.2
0B82:  GOTO   387
0B83:  MOVF   7D,W
0B84:  SUBLW  04
0B85:  BTFSS  03.2
0B86:  GOTO   46A
....................          apagarC=0; 
0B87:  BCF    03.5
0B88:  CLRF   39
....................          output_low(indicadorC); 
0B89:  BSF    03.5
0B8A:  BCF    08.0
0B8B:  BCF    03.5
0B8C:  BCF    08.0
....................          if(sub_indice_c==8) for(i=4;i<sub_indice_c;i++) deci_c = (deci_c<<1)|data_c[i]; 
0B8D:  MOVF   7D,W
0B8E:  SUBLW  08
0B8F:  BTFSS  03.2
0B90:  GOTO   3D6
0B91:  CLRF   33
0B92:  MOVLW  04
0B93:  MOVWF  32
0B94:  MOVF   33,F
0B95:  BTFSS  03.2
0B96:  GOTO   3D5
0B97:  MOVF   7D,W
0B98:  SUBWF  32,W
0B99:  BTFSC  03.0
0B9A:  GOTO   3D5
0B9B:  BCF    03.0
0B9C:  BSF    03.5
0B9D:  RLF    65,W
0B9E:  BCF    03.5
0B9F:  BSF    03.6
0BA0:  MOVWF  59
0BA1:  BSF    03.5
0BA2:  BCF    03.6
0BA3:  RLF    66,W
0BA4:  BCF    03.5
0BA5:  BSF    03.6
0BA6:  MOVWF  5A
0BA7:  BSF    03.5
0BA8:  BCF    03.6
0BA9:  RLF    67,W
0BAA:  BCF    03.5
0BAB:  BSF    03.6
0BAC:  MOVWF  5B
0BAD:  BSF    03.5
0BAE:  BCF    03.6
0BAF:  RLF    68,W
0BB0:  BCF    03.5
0BB1:  BSF    03.6
0BB2:  MOVWF  5C
0BB3:  MOVLW  10
0BB4:  BCF    03.6
0BB5:  ADDWF  32,W
0BB6:  MOVWF  04
0BB7:  BSF    03.7
0BB8:  MOVF   00,W
0BB9:  BSF    03.6
0BBA:  IORWF  59,W
0BBB:  BSF    03.5
0BBC:  BCF    03.6
0BBD:  MOVWF  65
0BBE:  BCF    03.5
0BBF:  BSF    03.6
0BC0:  MOVF   5A,W
0BC1:  BSF    03.5
0BC2:  BCF    03.6
0BC3:  MOVWF  66
0BC4:  BCF    03.5
0BC5:  BSF    03.6
0BC6:  MOVF   5B,W
0BC7:  BSF    03.5
0BC8:  BCF    03.6
0BC9:  MOVWF  67
0BCA:  BCF    03.5
0BCB:  BSF    03.6
0BCC:  MOVF   5C,W
0BCD:  BSF    03.5
0BCE:  BCF    03.6
0BCF:  MOVWF  68
0BD0:  BCF    03.5
0BD1:  INCF   32,F
0BD2:  BTFSC  03.2
0BD3:  INCF   33,F
0BD4:  GOTO   394
0BD5:  GOTO   419
....................          else for(i=0;i<sub_indice_c;i++) deci_c = (deci_c<<1)|data_c[i]; 
0BD6:  CLRF   33
0BD7:  CLRF   32
0BD8:  MOVF   33,F
0BD9:  BTFSS  03.2
0BDA:  GOTO   419
0BDB:  MOVF   7D,W
0BDC:  SUBWF  32,W
0BDD:  BTFSC  03.0
0BDE:  GOTO   419
0BDF:  BCF    03.0
0BE0:  BSF    03.5
0BE1:  RLF    65,W
0BE2:  BCF    03.5
0BE3:  BSF    03.6
0BE4:  MOVWF  59
0BE5:  BSF    03.5
0BE6:  BCF    03.6
0BE7:  RLF    66,W
0BE8:  BCF    03.5
0BE9:  BSF    03.6
0BEA:  MOVWF  5A
0BEB:  BSF    03.5
0BEC:  BCF    03.6
0BED:  RLF    67,W
0BEE:  BCF    03.5
0BEF:  BSF    03.6
0BF0:  MOVWF  5B
0BF1:  BSF    03.5
0BF2:  BCF    03.6
0BF3:  RLF    68,W
0BF4:  BCF    03.5
0BF5:  BSF    03.6
0BF6:  MOVWF  5C
0BF7:  MOVLW  10
0BF8:  BCF    03.6
0BF9:  ADDWF  32,W
0BFA:  MOVWF  04
0BFB:  BSF    03.7
0BFC:  MOVF   00,W
0BFD:  BSF    03.6
0BFE:  IORWF  59,W
0BFF:  BSF    03.5
0C00:  BCF    03.6
0C01:  MOVWF  65
0C02:  BCF    03.5
0C03:  BSF    03.6
0C04:  MOVF   5A,W
0C05:  BSF    03.5
0C06:  BCF    03.6
0C07:  MOVWF  66
0C08:  BCF    03.5
0C09:  BSF    03.6
0C0A:  MOVF   5B,W
0C0B:  BSF    03.5
0C0C:  BCF    03.6
0C0D:  MOVWF  67
0C0E:  BCF    03.5
0C0F:  BSF    03.6
0C10:  MOVF   5C,W
0C11:  BSF    03.5
0C12:  BCF    03.6
0C13:  MOVWF  68
0C14:  BCF    03.5
0C15:  INCF   32,F
0C16:  BTFSC  03.2
0C17:  INCF   33,F
0C18:  GOTO   3D8
....................          nipC[ic]=deci_C; 
0C19:  MOVLW  47
0C1A:  ADDWF  59,W
0C1B:  MOVWF  04
0C1C:  BCF    03.7
0C1D:  BSF    03.5
0C1E:  MOVF   65,W
0C1F:  MOVWF  00
....................          f_nip[2]=1; 
0C20:  MOVLW  01
0C21:  BCF    03.5
0C22:  MOVWF  55
....................          time_nip[2]=0; 
0C23:  CLRF   51
....................          ic++; 
0C24:  INCF   59,F
....................          if(ic==4) { 
0C25:  MOVF   59,W
0C26:  SUBLW  04
0C27:  BTFSS  03.2
0C28:  GOTO   468
....................             printf("MUXC-NIP:%u%u%u%u\r",nipC[0],nipC[1],nipC[2],nipC[3]);//MUXA-IDX:00C4DA5D 
0C29:  MOVLW  A0
0C2A:  BSF    03.6
0C2B:  MOVWF  0D
0C2C:  MOVLW  01
0C2D:  MOVWF  0F
0C2E:  BCF    03.0
0C2F:  MOVLW  09
0C30:  MOVWF  58
0C31:  BCF    0A.3
0C32:  BCF    03.6
0C33:  CALL   1C5
0C34:  BSF    0A.3
0C35:  MOVF   47,W
0C36:  BSF    03.6
0C37:  MOVWF  58
0C38:  MOVLW  1B
0C39:  MOVWF  59
0C3A:  BCF    0A.3
0C3B:  BCF    03.6
0C3C:  CALL   259
0C3D:  BSF    0A.3
0C3E:  MOVF   48,W
0C3F:  BSF    03.6
0C40:  MOVWF  58
0C41:  MOVLW  1B
0C42:  MOVWF  59
0C43:  BCF    0A.3
0C44:  BCF    03.6
0C45:  CALL   259
0C46:  BSF    0A.3
0C47:  MOVF   49,W
0C48:  BSF    03.6
0C49:  MOVWF  58
0C4A:  MOVLW  1B
0C4B:  MOVWF  59
0C4C:  BCF    0A.3
0C4D:  BCF    03.6
0C4E:  CALL   259
0C4F:  BSF    0A.3
0C50:  MOVF   4A,W
0C51:  BSF    03.6
0C52:  MOVWF  58
0C53:  MOVLW  1B
0C54:  MOVWF  59
0C55:  BCF    0A.3
0C56:  BCF    03.6
0C57:  CALL   259
0C58:  BSF    0A.3
0C59:  MOVLW  0D
0C5A:  BTFSS  0C.4
0C5B:  GOTO   45A
0C5C:  MOVWF  19
....................             memset(nipC, 0, sizeof(nipC)); 
0C5D:  MOVLW  47
0C5E:  MOVWF  04
0C5F:  BCF    03.7
0C60:  CLRF   77
0C61:  MOVLW  04
0C62:  MOVWF  78
0C63:  BCF    0A.3
0C64:  CALL   1BC
0C65:  BSF    0A.3
....................             ic=0; 
0C66:  CLRF   59
....................             f_nip[2]=0; 
0C67:  CLRF   55
....................          } 
.................... //!         printf("%Lu-C\r",deci_c); 
....................    } 
0C68:  GOTO   474
0C69:  BSF    03.5
....................    else { 
.................... //!         printf("Error de Lectura:"); 
....................          disable_interrupts(GLOBAL);//Deshabilito las interrupciones globales 
0C6A:  BCF    03.5
0C6B:  BCF    0B.6
0C6C:  BCF    0B.7
0C6D:  BTFSC  0B.7
0C6E:  GOTO   46C
....................          apagarC=0; 
0C6F:  CLRF   39
....................          output_low(indicadorC); 
0C70:  BSF    03.5
0C71:  BCF    08.0
0C72:  BCF    03.5
0C73:  BCF    08.0
.................... //!         for(i=0;i<sub_indice_c;i++) printf("%u",data_c[i]); 
....................    } 
....................    deci_c=0; 
0C74:  BSF    03.5
0C75:  CLRF   68
0C76:  CLRF   67
0C77:  CLRF   66
0C78:  CLRF   65
....................    deteccion_nulo_c=0; 
0C79:  CLRF   76
....................    pre_cuenta_c=0; 
0C7A:  CLRF   7B
....................    wieg_c=sub_indice_c=i=0; 
0C7B:  BCF    03.5
0C7C:  CLRF   33
0C7D:  CLRF   32
0C7E:  MOVF   32,W
0C7F:  MOVWF  7D
0C80:  MOVWF  7C
....................    memset(data_c, 0, sizeof(data_c) ); 
0C81:  MOVLW  10
0C82:  MOVWF  04
0C83:  BSF    03.7
0C84:  CLRF   77
0C85:  MOVLW  22
0C86:  MOVWF  78
0C87:  BCF    0A.3
0C88:  CALL   1BC
0C89:  BSF    0A.3
....................    enable_interrupts(GLOBAL); 
0C8A:  MOVLW  C0
0C8B:  IORWF  0B,F
....................  }//END TARJETA LEIDA 
....................  ////// 
....................  if( (wieg_d==1)&&(wiegand_cuenta_d>=2) ) { 
0C8C:  BSF    03.5
0C8D:  DECFSZ 6B,W
0C8E:  GOTO   5F2
0C8F:  MOVF   6E,W
0C90:  SUBLW  01
0C91:  BTFSC  03.0
0C92:  GOTO   5F2
....................    disable_interrupts(GLOBAL);//Deshabilito las interrupciones globales 
0C93:  BCF    03.5
0C94:  BCF    0B.6
0C95:  BCF    0B.7
0C96:  BTFSC  0B.7
0C97:  GOTO   495
.................... //!   printf("\r\nTipo:W%u ",sub_indice_d); 
....................    wieg_full_d=0; 
0C98:  BSF    03.5
0C99:  CLRF   6D
....................    deci_d=0; 
0C9A:  BCF    03.5
0C9B:  BSF    03.6
0C9C:  CLRF   35
0C9D:  CLRF   34
0C9E:  CLRF   33
0C9F:  CLRF   32
....................     
....................    if( (sub_indice_d==26)||(sub_indice_d==34) ){ 
0CA0:  BSF    03.5
0CA1:  BCF    03.6
0CA2:  MOVF   6C,W
0CA3:  SUBLW  1A
0CA4:  BTFSC  03.2
0CA5:  GOTO   4AA
0CA6:  MOVF   6C,W
0CA7:  SUBLW  22
0CA8:  BTFSS  03.2
0CA9:  GOTO   510
....................       for(i=1;i<sub_indice_d-1;i++) deci_d = (deci_d<<1)|data_d[i]; 
0CAA:  BCF    03.5
0CAB:  CLRF   33
0CAC:  MOVLW  01
0CAD:  MOVWF  32
0CAE:  MOVLW  01
0CAF:  BSF    03.5
0CB0:  SUBWF  6C,W
0CB1:  BCF    03.5
0CB2:  MOVF   33,F
0CB3:  BTFSS  03.2
0CB4:  GOTO   4D6
0CB5:  SUBWF  32,W
0CB6:  BTFSC  03.0
0CB7:  GOTO   4D6
0CB8:  BCF    03.0
0CB9:  BSF    03.6
0CBA:  RLF    32,W
0CBB:  MOVWF  59
0CBC:  RLF    33,W
0CBD:  MOVWF  5A
0CBE:  RLF    34,W
0CBF:  MOVWF  5B
0CC0:  RLF    35,W
0CC1:  MOVWF  5C
0CC2:  MOVLW  36
0CC3:  BCF    03.6
0CC4:  ADDWF  32,W
0CC5:  MOVWF  04
0CC6:  BSF    03.7
0CC7:  MOVF   00,W
0CC8:  BSF    03.6
0CC9:  IORWF  59,W
0CCA:  MOVWF  32
0CCB:  MOVF   5A,W
0CCC:  MOVWF  33
0CCD:  MOVF   5B,W
0CCE:  MOVWF  34
0CCF:  MOVF   5C,W
0CD0:  MOVWF  35
0CD1:  BCF    03.6
0CD2:  INCF   32,F
0CD3:  BTFSC  03.2
0CD4:  INCF   33,F
0CD5:  GOTO   4AE
....................       printf("MUXD-IDX:%08LX\r",deci_d); 
0CD6:  MOVLW  AA
0CD7:  BSF    03.6
0CD8:  MOVWF  0D
0CD9:  MOVLW  01
0CDA:  MOVWF  0F
0CDB:  BCF    03.0
0CDC:  MOVLW  09
0CDD:  MOVWF  58
0CDE:  BCF    0A.3
0CDF:  BCF    03.6
0CE0:  CALL   1C5
0CE1:  BSF    0A.3
0CE2:  BSF    03.6
0CE3:  MOVF   35,W
0CE4:  MOVWF  58
0CE5:  MOVLW  37
0CE6:  MOVWF  59
0CE7:  BCF    0A.3
0CE8:  BCF    03.6
0CE9:  CALL   21B
0CEA:  BSF    0A.3
0CEB:  BSF    03.6
0CEC:  MOVF   34,W
0CED:  MOVWF  58
0CEE:  MOVLW  37
0CEF:  MOVWF  59
0CF0:  BCF    0A.3
0CF1:  BCF    03.6
0CF2:  CALL   21B
0CF3:  BSF    0A.3
0CF4:  BSF    03.6
0CF5:  MOVF   33,W
0CF6:  MOVWF  58
0CF7:  MOVLW  37
0CF8:  MOVWF  59
0CF9:  BCF    0A.3
0CFA:  BCF    03.6
0CFB:  CALL   21B
0CFC:  BSF    0A.3
0CFD:  BSF    03.6
0CFE:  MOVF   32,W
0CFF:  MOVWF  58
0D00:  MOVLW  37
0D01:  MOVWF  59
0D02:  BCF    0A.3
0D03:  BCF    03.6
0D04:  CALL   21B
0D05:  BSF    0A.3
0D06:  MOVLW  0D
0D07:  BTFSS  0C.4
0D08:  GOTO   507
0D09:  MOVWF  19
....................       apagarD=1; 
0D0A:  MOVLW  01
0D0B:  MOVWF  3B
....................       time_apagarD=0; 
0D0C:  CLRF   3C
....................       f_nip[3]=0; 
0D0D:  CLRF   56
....................    } 
0D0E:  GOTO   5D5
0D0F:  BSF    03.5
....................    else if( (sub_indice_d==8)||(sub_indice_d==4) ) {//!         printf("Tecla:"); 
0D10:  MOVF   6C,W
0D11:  SUBLW  08
0D12:  BTFSC  03.2
0D13:  GOTO   518
0D14:  MOVF   6C,W
0D15:  SUBLW  04
0D16:  BTFSS  03.2
0D17:  GOTO   5CB
....................          apagarD=0; 
0D18:  BCF    03.5
0D19:  CLRF   3B
....................          output_low(indicadorD); 
0D1A:  BSF    03.5
0D1B:  BCF    08.1
0D1C:  BCF    03.5
0D1D:  BCF    08.1
....................          if(sub_indice_d==8) for(i=4;i<sub_indice_d;i++) deci_d = (deci_d<<1)|data_d[i]; 
0D1E:  BSF    03.5
0D1F:  MOVF   6C,W
0D20:  SUBLW  08
0D21:  BTFSS  03.2
0D22:  GOTO   550
0D23:  BCF    03.5
0D24:  CLRF   33
0D25:  MOVLW  04
0D26:  MOVWF  32
0D27:  MOVF   33,F
0D28:  BTFSS  03.2
0D29:  GOTO   54E
0D2A:  BSF    03.5
0D2B:  MOVF   6C,W
0D2C:  BCF    03.5
0D2D:  SUBWF  32,W
0D2E:  BTFSC  03.0
0D2F:  GOTO   54E
0D30:  BCF    03.0
0D31:  BSF    03.6
0D32:  RLF    32,W
0D33:  MOVWF  59
0D34:  RLF    33,W
0D35:  MOVWF  5A
0D36:  RLF    34,W
0D37:  MOVWF  5B
0D38:  RLF    35,W
0D39:  MOVWF  5C
0D3A:  MOVLW  36
0D3B:  BCF    03.6
0D3C:  ADDWF  32,W
0D3D:  MOVWF  04
0D3E:  BSF    03.7
0D3F:  MOVF   00,W
0D40:  BSF    03.6
0D41:  IORWF  59,W
0D42:  MOVWF  32
0D43:  MOVF   5A,W
0D44:  MOVWF  33
0D45:  MOVF   5B,W
0D46:  MOVWF  34
0D47:  MOVF   5C,W
0D48:  MOVWF  35
0D49:  BCF    03.6
0D4A:  INCF   32,F
0D4B:  BTFSC  03.2
0D4C:  INCF   33,F
0D4D:  GOTO   527
0D4E:  GOTO   57A
0D4F:  BSF    03.5
....................          else for(i=0;i<sub_indice_d;i++) deci_d = (deci_d<<1)|data_d[i]; 
0D50:  BCF    03.5
0D51:  CLRF   33
0D52:  CLRF   32
0D53:  MOVF   33,F
0D54:  BTFSS  03.2
0D55:  GOTO   57A
0D56:  BSF    03.5
0D57:  MOVF   6C,W
0D58:  BCF    03.5
0D59:  SUBWF  32,W
0D5A:  BTFSC  03.0
0D5B:  GOTO   57A
0D5C:  BCF    03.0
0D5D:  BSF    03.6
0D5E:  RLF    32,W
0D5F:  MOVWF  59
0D60:  RLF    33,W
0D61:  MOVWF  5A
0D62:  RLF    34,W
0D63:  MOVWF  5B
0D64:  RLF    35,W
0D65:  MOVWF  5C
0D66:  MOVLW  36
0D67:  BCF    03.6
0D68:  ADDWF  32,W
0D69:  MOVWF  04
0D6A:  BSF    03.7
0D6B:  MOVF   00,W
0D6C:  BSF    03.6
0D6D:  IORWF  59,W
0D6E:  MOVWF  32
0D6F:  MOVF   5A,W
0D70:  MOVWF  33
0D71:  MOVF   5B,W
0D72:  MOVWF  34
0D73:  MOVF   5C,W
0D74:  MOVWF  35
0D75:  BCF    03.6
0D76:  INCF   32,F
0D77:  BTFSC  03.2
0D78:  INCF   33,F
0D79:  GOTO   553
....................          nipD[id]=deci_d; 
0D7A:  MOVLW  4B
0D7B:  ADDWF  5A,W
0D7C:  MOVWF  04
0D7D:  BCF    03.7
0D7E:  BSF    03.6
0D7F:  MOVF   32,W
0D80:  MOVWF  00
....................          f_nip[3]=1; 
0D81:  MOVLW  01
0D82:  BCF    03.6
0D83:  MOVWF  56
....................          time_nip[3]=0; 
0D84:  CLRF   52
....................          id++; 
0D85:  INCF   5A,F
....................          if(id==4) { 
0D86:  MOVF   5A,W
0D87:  SUBLW  04
0D88:  BTFSS  03.2
0D89:  GOTO   5C9
....................             printf("MUXD-NIP:%u%u%u%u\r",nipD[0],nipD[1],nipD[2],nipD[3]);//MUXA-IDX:00C4DA5D 
0D8A:  MOVLW  B2
0D8B:  BSF    03.6
0D8C:  MOVWF  0D
0D8D:  MOVLW  01
0D8E:  MOVWF  0F
0D8F:  BCF    03.0
0D90:  MOVLW  09
0D91:  MOVWF  58
0D92:  BCF    0A.3
0D93:  BCF    03.6
0D94:  CALL   1C5
0D95:  BSF    0A.3
0D96:  MOVF   4B,W
0D97:  BSF    03.6
0D98:  MOVWF  58
0D99:  MOVLW  1B
0D9A:  MOVWF  59
0D9B:  BCF    0A.3
0D9C:  BCF    03.6
0D9D:  CALL   259
0D9E:  BSF    0A.3
0D9F:  MOVF   4C,W
0DA0:  BSF    03.6
0DA1:  MOVWF  58
0DA2:  MOVLW  1B
0DA3:  MOVWF  59
0DA4:  BCF    0A.3
0DA5:  BCF    03.6
0DA6:  CALL   259
0DA7:  BSF    0A.3
0DA8:  MOVF   4D,W
0DA9:  BSF    03.6
0DAA:  MOVWF  58
0DAB:  MOVLW  1B
0DAC:  MOVWF  59
0DAD:  BCF    0A.3
0DAE:  BCF    03.6
0DAF:  CALL   259
0DB0:  BSF    0A.3
0DB1:  MOVF   4E,W
0DB2:  BSF    03.6
0DB3:  MOVWF  58
0DB4:  MOVLW  1B
0DB5:  MOVWF  59
0DB6:  BCF    0A.3
0DB7:  BCF    03.6
0DB8:  CALL   259
0DB9:  BSF    0A.3
0DBA:  MOVLW  0D
0DBB:  BTFSS  0C.4
0DBC:  GOTO   5BB
0DBD:  MOVWF  19
....................             memset(nipD, 0, sizeof(nipD)); 
0DBE:  MOVLW  4B
0DBF:  MOVWF  04
0DC0:  BCF    03.7
0DC1:  CLRF   77
0DC2:  MOVLW  04
0DC3:  MOVWF  78
0DC4:  BCF    0A.3
0DC5:  CALL   1BC
0DC6:  BSF    0A.3
....................             id=0; 
0DC7:  CLRF   5A
....................             f_nip[1]=0; 
0DC8:  CLRF   54
....................          } 
.................... //!         printf("%Lu-D\r",deci_d); 
....................    } 
0DC9:  GOTO   5D5
0DCA:  BSF    03.5
....................    else { 
.................... //!         printf("Error de Lectura:"); 
....................          disable_interrupts(GLOBAL);//Deshabilito las interrupciones globales 
0DCB:  BCF    03.5
0DCC:  BCF    0B.6
0DCD:  BCF    0B.7
0DCE:  BTFSC  0B.7
0DCF:  GOTO   5CD
....................          apagarD=0; 
0DD0:  CLRF   3B
....................          output_low(indicadorD); 
0DD1:  BSF    03.5
0DD2:  BCF    08.1
0DD3:  BCF    03.5
0DD4:  BCF    08.1
.................... //!         for(i=0;i<sub_indice_d;i++) printf("%u",data_d[i]); 
....................    } 
....................    deci_d=0; 
0DD5:  BSF    03.6
0DD6:  CLRF   35
0DD7:  CLRF   34
0DD8:  CLRF   33
0DD9:  CLRF   32
....................    deteccion_nulo_d=0; 
0DDA:  BSF    03.5
0DDB:  BCF    03.6
0DDC:  CLRF   69
....................    pre_cuenta_d=0; 
0DDD:  CLRF   6A
....................    wieg_d=sub_indice_d=i=0; 
0DDE:  BCF    03.5
0DDF:  CLRF   33
0DE0:  CLRF   32
0DE1:  MOVF   32,W
0DE2:  BSF    03.5
0DE3:  MOVWF  6C
0DE4:  MOVWF  6B
....................    memset(data_d, 0, sizeof(data_d) ); 
0DE5:  MOVLW  36
0DE6:  MOVWF  04
0DE7:  BSF    03.7
0DE8:  CLRF   77
0DE9:  MOVLW  22
0DEA:  MOVWF  78
0DEB:  BCF    0A.3
0DEC:  BCF    03.5
0DED:  CALL   1BC
0DEE:  BSF    0A.3
....................    enable_interrupts(GLOBAL); 
0DEF:  MOVLW  C0
0DF0:  IORWF  0B,F
0DF1:  BSF    03.5
....................  }//END TARJETA LEIDA 
0DF2:  BCF    03.5
0DF3:  BCF    0A.3
0DF4:  BCF    0A.4
0DF5:  GOTO   41A (RETURN)
....................  ////// 
.................... }  
....................  
....................  

Configuration Fuses:
   Word  1: 3FA2   HS NOWDT PUT MCLR PROTECT BROWNOUT BORV19 PLLEN NODEBUG
   Word  2: 3FFF   NOVCAP
